{"version":3,"sources":["interpreter.js","header.js","prettyprint.js","App.js","serviceWorker.js","index.js"],"names":["RVAR_T","RAPP_T","RFUNCT_T","RNUM_T","RBOOL_T","RSTRING_T","RLIST_T","RSYM_T","initEnv","name","binding","type","value","args","forEach","cur","typeCheck","reduce","acc","length","firstArg","secondArg","car","cdr","Error","a","d","reverse","arg","thirdArg","isnull","val","parse","text","varRE","numRE","boolRE","strRE","test","numStr","match","rest","slice","trim","prog","boolStr","matches","parseFunct","funct","parseArg","concat","Object","toConsumableArray","parseQ","symRE","listRE","listArr","num","bool","str","sym","SyntaxError","interp","env","variable","undefined","ReferenceError","lookup","map","TypeError","unParse","join","parseCheck","parsed","typeString","gray","pink","yellow","allBools","progs","every","isBooleanFormula","formula","outputs","thenChildren","tableToBSL","table","inputToBSL","params","param","body","formulas","formulaToBSL","check_expects","examples","example","inputs","input","want","toBSL","program","dryRun","yo","imgPath","keyCount","takeKey","peekKey","lookahead","deepEquals","proga","progb","functCheck","argCheck","arga","i","elem","RemButton","props","react_default","createElement","className","style","src","alt","title","onClick","ValidatedInput","_this","classCallCheck","this","possibleConstructorReturn","getPrototypeOf","call","state","textChange","bind","assertThisInitialized","e","target","setState","isValid","onValid","dummy","onEmpty","size","placeholder","Math","max","onChange","React","Component","Succinct","tableChange","newTab","oldTab","alteredTabs","tables","indexOf","programChange","validName","modTab","tableVars","filter","otherTab","paramVars","reals","key","App_ValidatedInput","objectSpread","deadTab","aliveTabs","remTable","SuccinctTab","tableNames","formulasChange","SuccinctHead","paramsExamplesChange","SuccinctBody","paramNames","examplesFormulasChange","validProg","isgood","formulaChange","newForm","oldForm","alteredForms","form","countWidth","child","abyss","maxDepth","curMax","numParams","colSpan","deadForm","aliveForms","remFormula","_","children","countUp","depth","DepictFormula","numExamples","Parameters","validParam","modParam","paramChange","newParam","alteredParams","alteredExamples","deadParam","deadIndex","aliveParams","modExamples","remParam","Fragment","childChange","newChild","modChild","deadChild","aliveChildren","remChild","Array","fill","exampleChange","newExample","oldExample","exists","addAnotherOutputToFormula","deadExample","aliveExamples","removeOutputFromFormula","remExample","Inputs","inputsChange","Outputs","row","Want","wantChange","goodText","inputChange","newInput","oldInput","alteredInputs","TestCell","output","error","img","message","float","App","_this2","makeLookup","expr","lookups","globalEnv","calcFormula","localEnv","subExamples","maybeSpecial","newFormula","newProg","calkedProg","calculate","console","log","rows","cols","readOnly","Boolean","window","location","hostname","ReactDOM","render","src_App_0","document","getElementById","navigator","serviceWorker","ready","then","registration","unregister"],"mappings":"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","file":"static/js/main.c56cdb88.chunk.js","sourcesContent":["\n/****************\n   Interpreter\n****************/\n\nconst RVAR_T =    0;\nconst RAPP_T =    1;\nconst RFUNCT_T =   2;\nconst RNUM_T =    3;\nconst RBOOL_T =   4;\nconst RSTRING_T = 5;\nconst RLIST_T =   6;\nconst RSYM_T =    7;\n\nconst initEnv = [\n    // functions\n    {name: '+', binding: {type: RFUNCT_T,\n                          value: plus}},\n    {name: '-', binding: {type: RFUNCT_T,\n                          value: minus}},\n    {name: '*', binding: {type: RFUNCT_T,\n                          value: times}},\n    {name: '/', binding: {type: RFUNCT_T,\n                          value: divide}},\n    {name: 'car', binding: {type: RFUNCT_T,\n                            value: car}},\n    {name: 'first', binding: {type: RFUNCT_T,\n                              value: car}},\n    {name: 'cdr', binding: {type: RFUNCT_T,\n                            value: cdr}},\n    {name: 'rest', binding: {type: RFUNCT_T,\n                             value: cdr}},\n    {name: 'cons', binding: {type: RFUNCT_T,\n                             value: cons}},\n    {name: 'list', binding: {type: RFUNCT_T,\n                             value: list}},\n    {name: 'not', binding: {type: RFUNCT_T,\n                            value: not}},\n    {name: 'and', binding: {type: RFUNCT_T,\n                            value: and}},\n    {name: 'or', binding: {type: RFUNCT_T,\n                           value: or}},\n    {name: 'if', binding: {type: RFUNCT_T,\n                           value: rif}},\n    {name: 'eqv?', binding: {type: RFUNCT_T,\n                             value: iseqv}},\n    {name: 'null?', binding: {type: RFUNCT_T,\n                              value: isnull}},\n    {name: 'empty?', binding: {type: RFUNCT_T,\n                               value: isnull}},\n    {name: '=', binding: {type: RFUNCT_T,\n                          value: equalsign}},\n    {name: '>', binding: {type: RFUNCT_T,\n                          value: gtsign}},\n    {name: '>=', binding: {type: RFUNCT_T,\n                           value: gesign}},\n    {name: '<', binding: {type: RFUNCT_T,\n                          value: ltsign}},\n    {name: '<=', binding: {type: RFUNCT_T,\n                           value: lesign}},\n    // constants\n    {name: 'true', binding: {type: RBOOL_T,\n                             value: true}},\n    {name: 'false', binding: {type: RBOOL_T,\n                              value: false}},\n    {name: 'null', binding: {type: RLIST_T,\n                             value: null}},\n    {name: 'empty', binding: {type: RLIST_T,\n                              value: null}},\n];\n\n// String -> {prog: Program, rest: String}\n// parses all expressions except quoted expressions\nfunction parse(text) {\n    const varRE = /^[a-zA-Z+\\-*/?=><]+/; // change me\n    const appRE = /^\\(/;\n    const numRE = /^-?\\d+/; // this one doesn't permit fractions\n    const boolRE = /^#[tf]/;\n    const strRE = /^\"[^\"]*\"/;\n    const quoteRE = /^'/;\n\n    if (numRE.test(text)) {\n        let matches = text.match(numRE);\n        let numStr = matches[0];\n        let rest = text.slice(numStr.length).trim();\n        let num = {value: +numStr, type: RNUM_T};\n\n        return {prog: num, rest: rest};\n    } else if (varRE.test(text)) {\n        let matches = text.match(varRE);\n        let name = matches[0];\n        let rest = text.slice(name.length).trim();\n        let variable = {value: name, type: RVAR_T};\n\n        return {prog: variable, rest: rest};\n\n\n    } else if (boolRE.test(text)) {\n        let matches = text.match(boolRE);\n        let boolStr = matches[0];\n        let rest = text.slice(2).trim();\n        let bool = {value: boolStr === '#t', type: RBOOL_T};\n\n        return {prog: bool, rest: rest};\n\n    } else if (strRE.test(text)) {\n        let matches = text.match(strRE);\n        let str = {value: matches[0], type: RSTRING_T};\n        let rest = text.slice(matches[0].length).trim();\n\n        return {prog: str, rest: rest};\n\n    } else if (appRE.test(text)) {\n        text = text.slice(1).trim(); // remove open paren\n        let parseFunct = parse(text); // parse function\n        let funct = parseFunct.prog; // get function\n        text = parseFunct.rest; // get past function\n        let args = [];\n\n        while (text[0] !== ')') {\n            let parseArg = parse(text);\n            args = [...args, parseArg.prog];\n            text = parseArg.rest;\n        }\n\n        let app = {value: {funct: funct, args: args}, type: RAPP_T};\n        let rest = text.slice(1).trim(); // remove close paren\n\n        return {prog: app, rest: rest};\n\n    } else if (quoteRE.test(text)) {\n        return parseQ(text);\n    }\n\n    throw new SyntaxError('Invalid Syntax: \"' + text + '\"');\n}\n\n// String -> {prog: Program, rest: String}\n// parses quoted expressions\nfunction parseQ(text) {\n    const symRE = /^'?[a-zA-Z+\\-*/?=><#\"]+/; // change me\n    const listRE = /^'?\\s*\\(/;\n    const numRE = /^'?-?\\d+/; // this one doesn't permit fractions\n    const boolRE = /^#[tf]/;\n    const strRE = /^\"[^\"]*\"/;\n\n\n    if (listRE.test(text)) {\n        text = text.slice(text.match(listRE)[0].length).trim(); // remove quote, open paren\n        let listArr = [];\n\n        while (text[0] !== ')') {\n            let cur = parseQ(text);\n            listArr = [cur.prog, ...listArr]; // listArr is constructed backwards\n            text = cur.rest;\n        }\n\n        let rest = text.slice(1).trim();\n        let prog = listArr.reduce((acc, cur) => ({value: {a: cur, d: acc}, type: RLIST_T}), {value: null, type: RLIST_T}); // turn listArr into an Rlist\n\n        return {prog: prog, rest: rest};\n\n    } else if (numRE.test(text)) {\n        let matches = text.match(numRE);\n        let numStr = matches[0];\n        let rest = text.slice(numStr.length).trim();\n        let num = {value: +numStr, type: RNUM_T};\n\n        return {prog: num, rest: rest};\n\n    } else if (boolRE.test(text)) {\n        let matches = text.match(boolRE);\n        let boolStr = matches[0];\n        let rest = text.slice(2).trim();\n        let bool = {value: boolStr === '#t', type: RBOOL_T};\n\n        return {prog: bool, rest: rest};\n\n    } else if (strRE.test(text)) {\n        let matches = text.match(strRE);\n        let str = {value: matches[0], type: RSTRING_T};\n        let rest = text.slice(matches[0].length).trim();\n\n        return {prog: str, rest: rest};\n\n    } else if (symRE.test(text)) {\n        let matches = text.match(symRE);\n        let value = matches[0];\n        value = value[0] === '\\'' ? value : '\\'' + value;\n        let sym = {value: value, type: RSYM_T};\n        let rest = text.slice(matches[0].length).trim();\n\n        return {prog: sym, rest: rest};\n    }\n\n    throw new SyntaxError('Invalid Syntax: \"' + text + '\"');\n}\n\n/***\n    Environment: [Variable]\n    Variable:    {name:    String,\n    binding: Program}\n***/\n\n// Program -> Environment -> Program\nfunction interp(prog, env) {\n    function lookup(name) {\n        let val = env.reduce((acc, variable) => {\n            if (acc !== undefined) {\n                return acc;\n            }\n\n            return variable.name === name ? variable.binding : undefined;\n        }, undefined);\n\n        if (val === undefined){\n            throw new ReferenceError(name + ' isn\\'t defined');\n        }\n\n        return val;\n    }\n\n    switch(prog.type) {\n    case RNUM_T:\n        return prog;\n    case RBOOL_T:\n        return prog;\n    case RSTRING_T:\n        return prog;\n    case RLIST_T:\n        return prog;\n    case RSYM_T:\n        return prog;\n    case RVAR_T:\n        return lookup(prog.value);\n    case RFUNCT_T:\n        return prog;\n    case RAPP_T:\n        // interpret function (valof rator env)\n        let funct = interp(prog.value.funct, env);\n        // interpret arguments (valof rand env)\n        let args = prog.value.args.map((arg) => interp(arg, env));\n\n        typeCheck(funct, RFUNCT_T);\n\n        return funct.value(args);\n\n    default:\n        throw new TypeError(\"Unknown Type \" + prog.value);\n    }\n}\n\n// Program -> String\nfunction unParse(prog) {\n    switch (prog.type) {\n    case RNUM_T:\n        return prog.value;\n    case RBOOL_T:\n        return '#' + (prog.value ? 'true' : 'false');\n    case RSTRING_T:\n        return prog.value;\n    case RLIST_T:\n        if (prog.value === null) {\n            return '\\'()';\n        } else {\n            return `(cons ${unParse(prog.value.a)} ${unParse(prog.value.d)})`;\n        }\n    case RSYM_T:\n        return prog.value;\n    case RVAR_T:\n        return prog.value;\n    case RFUNCT_T:\n        return 'function';\n    case RAPP_T:\n        return `(${unParse(prog.value.funct)} ${prog.value.args.map(unParse).join(' ')})`;\n    default:\n        return 'error or something';\n    }\n}\n\n// String -> Program\n// parses text and checks for syntax errors based on what's returned\nfunction parseCheck(text) {\n    let parsed = parse(text);\n\n    switch (parsed.rest) {\n    case '':\n        break;\n    default:\n        throw new SyntaxError('Parsing Error');\n    }\n\n    return parsed.prog;\n}\n\n// Program -> Number -> Side Effect Maybe\nfunction typeCheck(prog, type){\n    let typeString = '';\n    switch (type) {\n    case RVAR_T:\n        typeString = 'variable';\n        break;\n    case RAPP_T:\n        typeString = 'application';\n        break;\n    case RFUNCT_T:\n        typeString = 'function';\n        break;\n    case RNUM_T:\n        typeString = 'number';\n        break;\n    case RBOOL_T:\n        typeString = 'boolean';\n        break;\n    case RSTRING_T:\n        typeString = 'string';\n        break;\n    case RLIST_T:\n        typeString = 'list';\n        break;\n    case RSYM_T:\n        typeString = 'symbol';\n        break;\n    default:\n        typeString = '???';\n    }\n\n    if (prog.type !== type){\n        throw new TypeError(unParse(prog) + ' ain\\'t a ' + typeString);\n    }\n}\n\nfunction plus(args) {\n    args.forEach((cur) => typeCheck(cur, RNUM_T));\n\n    return args.reduce((acc, cur) => {\n        return {value: acc.value + cur.value,\n                type: RNUM_T};\n    });\n}\nfunction minus(args) {\n    args.forEach((cur) => typeCheck(cur, RNUM_T));\n\n    return args.reduce((acc, cur) => {\n        return {value: acc.value - cur.value,\n                type: RNUM_T};\n    });\n}\nfunction times(args) {\n    args.forEach((cur) => typeCheck(cur, RNUM_T));\n\n    return args.reduce((acc, cur) => {\n        return {value: acc.value * cur.value,\n                type: RNUM_T};\n    });\n}\nfunction divide(args) {\n    if (args.length === 1) {\n        let firstArg = args[0];\n\n        typeCheck(firstArg, RNUM_T);\n\n        return {value: 1 / firstArg.value,\n                type: RNUM_T};\n    } else if (args.length === 2) {\n        let firstArg = args[0];\n        let secondArg = args[1];\n\n        typeCheck(firstArg, RNUM_T);\n        typeCheck(secondArg, RNUM_T);\n\n        return {value: firstArg.value / secondArg.value,\n                type: RNUM_T};\n    }\n\n    args.forEach((cur) => typeCheck(cur, RNUM_T));\n    return {value: false, type: RBOOL_T};\n}\nfunction car(args) {\n    if (args.length !== 1) {\n        throw new Error('arity mismatch');\n    }\n\n    let firstArg = args[0];\n\n    typeCheck(firstArg, RLIST_T);\n\n    return firstArg.value.a;\n}\nfunction cdr(args) {\n    if (args.length !== 1) {\n        throw new Error('arity mismatch');\n    }\n\n    let firstArg = args[0];\n\n    typeCheck(firstArg, RLIST_T);\n\n    return firstArg.value.d;\n}\nfunction cons(args) {\n    if (args.length !== 2) {\n        throw new Error('arity mismatch');\n    }\n\n    let firstArg = args[0];\n    let secondArg = args[1];\n\n    // because BSL\n    typeCheck(secondArg, RLIST_T);\n\n    return {value: {a: firstArg, d: secondArg},\n            type: RLIST_T};\n}\nfunction list(args) {\n    return args.reverse().reduce((acc, arg) => ({value: {a: arg, d: acc},\n                                                       type: RLIST_T}),\n                                       {value: null,\n                                        type: RLIST_T});\n}\nfunction not(args) {\n    if (args.length !== 1) {\n        throw new Error('arity mismatch');\n    }\n\n    let firstArg = args[0];\n\n    return {value: firstArg.value === false,\n            type: RBOOL_T};\n}\nfunction iseqv(args) {\n    if (args.length !== 2) {\n        throw new Error('arity mismatch');\n    }\n\n    let firstArg = args[0];\n    let secondArg = args[1];\n\n    return {value: firstArg.value === secondArg.value,\n            type: RBOOL_T};\n}\nfunction and(args) {\n    return args.reduce((acc, cur) => {\n        return acc.value !== false ? cur : {value: false, type: RBOOL_T};\n    }, {value: true, type: RBOOL_T});\n\n}\nfunction or(args) {\n    return args.reduce((acc, cur) => {\n        return acc.value !== false ? acc : cur;\n    }, {value: true, type: RBOOL_T});\n\n}\nfunction rif(args) {\n    if (args.length !== 3) {\n        throw new Error('arity mismatch');\n    }\n\n    let firstArg = args[0];\n    let secondArg = args[1];\n    let thirdArg = args[2];\n\n    typeCheck(firstArg, RBOOL_T);\n\n    return firstArg.value ? secondArg : thirdArg;\n}\nfunction isnull(args) {\n    if (args.length !== 1) {\n        throw new Error('arity mismatch');\n    }\n\n    let firstArg = args[0];\n\n    return {value: firstArg.value === null && firstArg.type === RLIST_T,\n            type: RBOOL_T};\n}\nfunction equalsign(args) {\n    args.forEach((cur) => typeCheck(cur, RNUM_T));\n\n    let val = args.reduce((acc, cur) => {\n\n        if (acc.value === false) {\n            return {value: false, type: RBOOL_T};\n        }\n\n        return acc.value===cur.value ? acc : {value: false, type: RBOOL_T};\n    });\n\n    if (val.value === false){\n        return val;\n    } else {\n        return {value: true, type: RBOOL_T};\n    }\n}\nfunction gtsign(args) {\n    args.forEach((cur) => typeCheck(cur, RNUM_T));\n\n    let val = args.reduce((acc, cur) => {\n\n        if (acc.value === false) {\n            return {value: false, type: RBOOL_T};\n        }\n\n        return acc.value > cur.value ? acc : {value: false, type: RBOOL_T};\n    });\n\n    if (val.value === false){\n        return val;\n    } else {\n        return {value: true, type: RBOOL_T};\n    }\n}\nfunction gesign(args) {\n    args.forEach((cur) => typeCheck(cur, RNUM_T));\n\n    let val = args.reduce((acc, cur) => {\n\n        if (acc.value === false) {\n            return {value: false, type: RBOOL_T};\n        }\n\n        return acc.value >= cur.value ? acc : {value: false, type: RBOOL_T};\n    });\n\n    if (val.value === false){\n        return val;\n    } else {\n        return {value: true, type: RBOOL_T};\n    }\n}\nfunction ltsign(args) {\n    args.forEach((cur) => typeCheck(cur, RNUM_T));\n\n    let val = args.reduce((acc, cur) => {\n\n        if (acc.value === false) {\n            return {value: false, type: RBOOL_T};\n        }\n\n        return acc.value < cur.value ? acc : {value: false, type: RBOOL_T};\n    });\n\n    if (val.value === false){\n        return val;\n    } else {\n        return {value: true, type: RBOOL_T};\n    }\n}\nfunction lesign(args) {\n    args.forEach((cur) => typeCheck(cur, RNUM_T));\n\n    let val = args.reduce((acc, cur) => {\n\n        if (acc.value === false) {\n            return {value: false, type: RBOOL_T};\n        }\n\n        return acc.value <= cur.value ? acc : {value: false, type: RBOOL_T};\n    });\n\n    if (val.value === false){\n        return val;\n    } else {\n        return {value: true, type: RBOOL_T};\n    }\n}\n\nexport {interp, parseCheck, unParse, initEnv, RVAR_T, RAPP_T, RFUNCT_T, RNUM_T, RBOOL_T, RSTRING_T, RLIST_T, RSYM_T};\n","import {RBOOL_T} from './interpreter.js';\n\n/************\n    Colors\n************/\n\n// value to put in child formulas that don't have an output for that row\nexport const gray = {gray: 'gray'};\n// value to put in child formulas that have an error output for that row (non-boolean and non-gray)\nexport const pink = {pink: 'pink'};\n// value that indicates an uninitialized input\nexport const yellow = {yellow: 'yellow'};\n\n/*********************\n   Functions I Want\n*********************/\n// [Program] -> Boolean\n// returns true if progs has at least one member and all of its members are boooleans\n//    otherwise returns false\nexport function allBools(progs){\n    if (progs.length === 0) {\n        return false;\n    }\n\n    return progs.every((prog) => prog.type === RBOOL_T || prog === gray);\n}\n\nexport function isBooleanFormula(formula) {\n    return allBools(formula.outputs) || formula.thenChildren !== undefined;\n}\n\n","import {unParse} from './interpreter.js';\nimport {isBooleanFormula, yellow} from './header.js';\n\n/**************************************\n    Thing that Turns Tables Into BSL\n**************************************/\n\n// [Table] -> String\nfunction toBSL(program) {\n    return program.map(tableToBSL).join('\\n\\n\\n');\n}\n\n// Table -> String\nfunction tableToBSL(table) {\n    let name = inputToBSL(table.name);\n    let params = table.params.map((param) => inputToBSL(param.name)).join(' ');\n    let body = table.formulas.map(formulaToBSL).join('\\n');\n    let check_expects = table.examples.map((example) => (\n        `(check-expect (${name} ${example.inputs.map((input) => inputToBSL(input.prog)).join(' ')}) ${inputToBSL(example.want)})`\n    )).join('\\n');\n\n    return `(define (${name} ${params})\\n${body})\\n\\n${check_expects}`;\n}\n\n// Formula -> String\nfunction formulaToBSL(formula) {\n    if (isBooleanFormula(formula)) {\n        return `(cond [${inputToBSL(formula.prog)} ${formula.thenChildren.map(formulaToBSL).join(' ')}])`;\n    } else {\n        return inputToBSL(formula.prog);\n    }\n}\n\n// Input (yellow or string or program) -> String\nfunction inputToBSL(input) {\n    if (input === yellow) { // init\n        return '...';\n    } else if (typeof input === 'string') { // name\n        return input;\n    } else { // program\n        return unParse(input);\n    }\n}\n\nexport default toBSL;\n","import React from 'react';\nimport {interp, parseCheck, unParse, initEnv, RAPP_T, RFUNCT_T, RBOOL_T, RLIST_T} from './interpreter.js';\nimport {gray, pink, yellow, allBools, isBooleanFormula} from './header.js';\nimport toBSL from './prettyprint.js';\nimport './App.css';\n\n/*****************************\n  Universal Constants I Want\n*****************************/\n// value to indicate a dry run, i.e. don't actually change the underlying structure, just say\n// if the given value exists or not\nconst dryRun = {yo: 'don\\'t actually change anything'};\n// image path\nconst imgPath = './images/';\n\n\n/*********************\n    Key Management\n*********************/\n// variable used by takeKey and peekKey to generate keys\nlet keyCount = 0;\n\n// Number\n// returns a unique key\nfunction takeKey() {\n    return keyCount++;\n}\n\n// [Number] -> Number (the brackets here mean optional, not array)\n// returns current key without changing it\n// shoud be used to look at current state of key without actually taking it\n// optionally takes a number as an argument, in which case it returns the key that number\n// of steps ahead of the current key\nfunction peekKey(lookahead) {\n    if (lookahead === undefined) {\n        return keyCount;\n    } else {\n        return keyCount + lookahead;\n    }\n}\n\n// Program -> Program -> Boolean\n// checks if two programs are equivalent, recurs on lists and applications\n// may not quite work on functions because I use js functions, not data represented closures or something\n//    thus 2 functions are only equal if they're a reference to the same object\nfunction deepEquals(proga, progb) {\n    if (proga.type !== progb.type) {\n        return false;\n    }\n\n    if (proga.type === RLIST_T) {\n        if (proga.value === null || progb.value === null) {\n            return proga.value === progb.value;\n        }\n        return deepEquals(proga.value.a, progb.value.a) && deepEquals(proga.value.d, progb.value.d);\n    }\n\n    // this case will prolly never even happen...\n    if (proga.type === RAPP_T) {\n        if (proga.value.args.length !== progb.value.args.length) {\n            return false;\n        }\n        let functCheck = deepEquals(proga.value.funct, progb.value.funct);\n        let argCheck = proga.value.args.map((arga, i) => deepEquals(arga, progb.value.args[i])).every((elem) => elem);\n        return functCheck && argCheck;\n    }\n\n    return proga.value === progb.value;\n}\n\n/*********************\n   React Components\n*********************/\n\n/*** Buttons ***/\n// Button that probably removes something\nfunction RemButton(props){\n    return (\n        <div className='cross_button'>\n          <input\n            type={'image'}\n            style={props.style}\n            src={'./images/smallCross.png'}\n            alt='Remove'\n            title={props.title}\n            onClick={props.onClick}/>\n        </div>\n    );\n}\n\n/*** Inputs ***/\nclass ValidatedInput extends React.Component {\n    constructor(props) {\n        super(props);\n        this.state = {text: ''};\n\n        this.textChange = this.textChange.bind(this);\n    }\n\n    textChange(e) {\n        let text = e.target.value;\n\n        this.setState((state) => ({text}));\n\n        if (this.props.isValid(text)) {\n            this.props.onValid(text);\n        } else if (text === '' && !this.props.dummy) {\n            this.props.onEmpty();\n        }\n\n    }\n\n    render() {\n        let className;\n        if (this.props.dummy) {\n            className = 'dummy_input';\n        } else if (this.props.isValid(this.state.text)) {\n            className = 'valid_input';\n        } else if (this.state.text === '') {\n            className = 'empty_input';\n        } else {\n            className = 'invalid_input';\n        }\n        \n        let size;\n        if (this.state.text.length === 0)\n            size = this.props.placeholder.length;\n        else\n            size = Math.max(this.state.text.length + 2, 4);\n\n        return (\n            <input\n              className={className}\n              size={size}\n              placeholder={this.props.placeholder}\n              type={'text'}\n              value={this.state.text}\n              onChange={this.textChange}\n            />\n        );\n    }\n}\n\n/*** Table Sections ***/\n// let's put everything in one table woo\nfunction Succinct(props) {\n\n    function tableChange(newTab, oldTab) {\n        const exists = props.tables.indexOf(oldTab) !== -1;\n\n        let alteredTabs;\n        if (exists) {\n            alteredTabs = props.tables.map((table) => table === oldTab ? newTab : table);\n        } else {\n            alteredTabs = [...props.tables, newTab];\n        }\n\n        props.programChange(alteredTabs);\n    }\n\n    function remTable(deadTab) {\n        let aliveTabs = props.tables.filter((table) => table !== deadTab);\n        props.programChange(aliveTabs);\n    }\n\n    // String -> Boolean\n    function validName(text, modTab) {\n        function lookup(name, env) {\n            return env.reduce((acc, variable) => {\n                if (acc) {\n                    return true;\n                }\n\n                return variable.name === name;\n\n            }, false);\n        }\n\n        let tableVars = props.tables.filter((table) => table !== modTab).map((otherTab) => ({name: otherTab.name, binding: null}));\n        let paramVars = modTab.params.map((param) => ({name: param, binding: null}));\n        let env = [...initEnv, ...tableVars, ...paramVars];\n\n        const varRE = /^[a-zA-Z+\\-*/?=><]+$/; // change me\n\n        return varRE.test(text) && !lookup(text, env);\n    }\n\n    const reals = props.tables.map((table) => (\n        <div key={table.key} className='table_method' >\n          <div className='full_cell'>\n            <ValidatedInput\n              dummy={false}\n              placeholder='Table Name'\n              isValid={(text) => validName(text, table)}\n              onValid={(text) => tableChange({...table,\n                                              name: text},\n                                             table)}\n              onEmpty={() => tableChange({...table,\n                                          name: yellow},\n                                         table)}\n            />\n            <RemButton\n              onClick={() => remTable(table)}\n              title='Remove this table'\n            />\n          </div>\n          <SuccinctTab\n            table={table}\n            tableNames={props.tables.map((table) => table.name)}\n            tableChange={(newTab) => tableChange(newTab, table)}\n          />\n        </div>\n    ));\n\n    const dummy = (\n        <div key={peekKey()} className='table_method'>\n          <div className='full_cell'>\n            <ValidatedInput\n              dummy={true}\n              placeholder='Table Name'\n              isValid={(text) => validName(text, {params: []})}\n              onValid={(text) => tableChange({name: text,\n                                              examples: [],\n                                              formulas: [],\n                                              params: [],\n                                              key: takeKey()},\n                                             {})}\n            />\n          </div>\n          <SuccinctTab\n            table={{name: '',\n                    examples: [],\n                    formulas: [],\n                    params: [],\n                    key: peekKey()}}\n            tableNames={props.tables.map((table) => table.name)}\n            tableChange={(newTab) => tableChange(newTab, {})}\n          />\n        </div>\n    );\n\n    return (\n        <div>\n          {[...reals, dummy]}\n        </div>\n    );\n}\n\nfunction SuccinctTab(props) {\n    function paramsExamplesChange(params, examples) {\n        props.tableChange({...props.table, params, examples});\n    }\n\n    function formulasChange(formulas) {\n        props.tableChange({...props.table, formulas});\n    }\n\n    function examplesFormulasChange(examples, formulas) {\n        props.tableChange({...props.table, examples, formulas});\n    }\n\n    return (\n        <table className={'html_table'}>\n          <SuccinctHead\n            params={props.table.params}\n            examples={props.table.examples}\n            tableNames={props.tableNames}\n            paramsExamplesChange={paramsExamplesChange}\n\n            formulas={props.table.formulas}\n            formulasChange={formulasChange}\n          />\n          <SuccinctBody\n            examples={props.table.examples}\n            formulas={props.table.formulas}\n            paramNames={props.table.params.map((param) => param.name)}\n            examplesFormulasChange={examplesFormulasChange}\n            formulasChange={formulasChange}\n          />\n        </table>\n    );\n}\n\nfunction SuccinctHead(props) {\n    // String -> Boolean\n    // checks if the given string is a valid program\n    function validProg(text) {\n        let isgood = true;\n\n        try {\n            parseCheck(text);\n        } catch(e) {\n            if (e instanceof SyntaxError) {\n                isgood = false;\n            } else { // this should never happen\n                throw e;\n            }\n        }\n\n        return isgood;\n    }\n\n    // Formula -> Side Effect\n    // removes a given formula from the tree\n    function remFormula(deadForm) {\n        const aliveForms = props.formulas.filter((formula) => formula !== deadForm);\n        props.formulasChange(aliveForms);\n    }\n\n    // Formula -> Formula -> Side Effect\n    // replaces one formula with another one\n    function formulaChange(newForm, oldForm) {\n\n        let alteredForms;\n        if (props.formulas.indexOf(oldForm) === -1) {\n            alteredForms = [...props.formulas, newForm];\n        } else {\n            alteredForms = props.formulas.map((form) => form === oldForm ? newForm : form);\n        }\n        props.formulasChange(alteredForms);\n    }\n\n    // Formula -> Number -> Number\n    // gives the maximum depth of a Formula, second parameter is an accumulator\n    function maxDepth(formula, curMax) {\n        if (!isBooleanFormula(formula)) {\n            return curMax;\n        } else {\n            return formula.thenChildren.reduce((acc, child) => Math.max(acc, maxDepth(child, curMax + 1)), curMax + 1);\n        }\n    }\n\n    function countWidth(formula) {\n        if (!isBooleanFormula(formula)) {\n            return 1;\n        } else {\n            return formula.thenChildren.reduce((acc, child) => acc + countWidth(child), 2);\n        }\n    }\n\n\n    // Number -> [Number]\n    // takes a number, returns an array that counts from 1 to that number, input of 0 gives empty array\n    // e.g. countUp(5) -> [1, 2, 3, 4, 5]\n    function countUp(num) {\n        // special case: want an empty array for 0\n        if (num === 0) {\n            return [];\n        } else if (num === 1)\n            return [1];\n        else\n            return [...countUp(num - 1), num];\n    }\n\n    const abyss = props.formulas.reduce((acc, formula) => Math.max(acc, maxDepth(formula, 0)), 0);\n    const numParams = props.params.length;\n\n    const reals = props.formulas.map((formula) => (\n        <th key={formula.key} colSpan={countWidth(formula)} >\n          <div className='full_cell'>\n            <ValidatedInput\n              placeholder={'Formula'}\n              dummy={false}\n              isValid={validProg}\n              onValid={(text) => formulaChange({...formula,\n                                                prog: parseCheck(text)},\n                                               formula)}\n              onEmpty={() => formulaChange({...formula,\n                                            prog: yellow},\n                                           formula)}\n            />\n            <RemButton\n              title={'Remove formula'}\n              onClick={() => remFormula(formula)}\n            />\n          </div>\n        </th>\n    ));\n\n    const dummy = (\n        <th key={peekKey()} colSpan={1}>\n          <div className='full_cell'>\n            <ValidatedInput\n              dummy={true}\n              placeholder='Formula'\n              isValid={validProg}\n              onValid={(text) => formulaChange({prog: parseCheck(text),\n                                                outputs: props.examples.map((_) => yellow),\n                                                key: takeKey()},\n                                               {})}\n            />\n          </div>\n        </th>\n    );\n\n    const children = countUp(abyss).map((depth) => (\n        <tr key={depth}>\n          <th colSpan={numParams + 2}>{/* empty cell to align with example RemButton and Parameters */}</th>\n          {props.formulas.map((formula) => (\n              <DepictFormula\n                key={formula.key}\n                formula={formula}\n                depth={depth}\n                numExamples={props.examples.length}\n                formulaChange={(newForm) => formulaChange(newForm, formula)}\n              />\n          ))}\n        </tr>\n    ));\n\n    return (\n        <thead>\n          <tr>\n            <Parameters\n              params={props.params}\n              examples={props.examples}\n              tableNames={props.tableNames}\n              paramsExamplesChange={props.paramsExamplesChange}\n            />\n            {/* top level formulas */}\n            {[...reals, dummy]}\n          </tr>\n          {/* rest of formulas */}\n          {children}\n        </thead>\n    );\n}\n\nfunction Parameters(props) {\n    // \n    function validParam(text, modParam) {\n        function lookup(name, env) {\n            return env.reduce((acc, variable) => {\n                if (acc) {\n                    return true;\n                }\n\n                return variable.name === name;\n\n            }, false);\n        }\n\n        // These are not technically Variables, see note above\n        let paramVars = props.params.filter((param) => param !== modParam).map((param) => ({name: param.name, binding: null}));\n        let tableVars = props.tableNames.map((name) => ({name: name, binding: null}));\n        let env = [...initEnv, ...tableVars, ...paramVars];\n\n        const varRE = /^[a-zA-Z+\\-*/?=><]+$/; // change me\n\n        return varRE.test(text) && !lookup(text, env);\n    }\n\n    function remParam(deadParam) {\n        const deadIndex = props.params.indexOf(deadParam);\n        const aliveParams = props.params.filter((param) => param !== deadParam);\n\n        // need to maintain #inputs = #params\n        const modExamples = props.examples.map((example => ({...example,\n                                                             inputs: example.inputs.filter((_, i) => i !== deadIndex)})));\n\n        props.paramsExamplesChange(aliveParams, modExamples);\n    }\n\n    // String -> Number -> Side Effect\n    // changes the name of the given parameter\n    // if that parameter doesn't exist yet, it makes it\n    function paramChange(newParam, modParam) {\n\n        let alteredParams, alteredExamples;\n        if (props.params.indexOf(modParam) === -1) {\n            alteredParams = [...props.params, newParam];\n            // need to maintain #inputs = #params\n            alteredExamples = props.examples.map((example) => ({...example,\n                                                                inputs: [...example.inputs, {prog: yellow, key: takeKey()}]}));\n        } else {\n            alteredParams = props.params.map((param) => param === modParam ? newParam : param);\n            // examples don't actually change\n            alteredExamples = props.examples;\n        }\n\n        props.paramsExamplesChange(alteredParams, alteredExamples);\n    }\n\n    const reals = props.params.map((param) => (\n        <th key={param.key} >\n          <div className='full_cell'>\n            <ValidatedInput\n              dummy={false}\n              placeholder='Parameter'\n              isValid={(text) => validParam(text, param)}\n              onValid={(text) => paramChange({...param,\n                                              name: text},\n                                             param)}\n              onEmpty={() => paramChange({...param,\n                                          name: yellow},\n                                         param)}\n            />\n            <RemButton\n              title='remove this parameter'\n              onClick={() => remParam(param)}\n            />\n          </div>\n        </th>\n    ));\n\n    const dummy = (\n        <th key={peekKey()}>\n          <div className='full_cell'>\n            <ValidatedInput\n              dummy={true}\n              placeholder='Parameter'\n              isValid={(text) => validParam(text, {})}\n              onValid={(text) => paramChange({name: text,\n                                              key: takeKey()},\n                                             {})}\n            />\n          </div>\n        </th>\n    );\n\n    return (\n        <React.Fragment>\n          <th>{/* empty cell to align with example RemButtons */}</th>\n          <React.Fragment>\n            {[...reals, dummy]}\n          </React.Fragment>\n        </React.Fragment>\n    );\n}\n\n/*\n  props: formula, depth, kill, formulaChange\n*/\nfunction DepictFormula(props) {\n    function validProg(text) {\n        let isgood = true;\n\n        try {\n            parseCheck(text);\n        } catch(e) {\n            if (e instanceof SyntaxError) {\n                isgood = false;\n            } else {\n                throw e;\n            }\n        }\n\n        return isgood;\n    }\n\n    // this is pretty macabre...\n    function remChild(deadChild) {\n        const aliveChildren = props.formula.thenChildren.filter((child) => child !== deadChild);\n        props.formulaChange({...props.formula, thenChildren: aliveChildren});\n    }\n\n    function childChange(newChild, modChild) {\n        let children;\n        if (props.formula.thenChildren.indexOf(modChild) === -1) {\n            children = [...props.formula.thenChildren, newChild];\n        } else {\n            children = props.formula.thenChildren.map((child) => child === modChild ? newChild : child);\n        }\n        props.formulaChange({...props.formula, thenChildren: children});\n    }\n\n    function countWidth(formula) {\n        if (!isBooleanFormula(formula)) {\n            return 1;\n        } else {\n            return formula.thenChildren.reduce((acc, child) => acc + countWidth(child), 2);\n        }\n    }\n\n    if (props.depth > 1) {\n        return (\n            <React.Fragment>\n              <th>{/* empty cell to align with parent input */}</th>\n              {isBooleanFormula(props.formula) ?\n               <React.Fragment>\n                 {props.formula.thenChildren.map((child) => (\n                     <DepictFormula\n                       key={child.key}\n                       formula={child}\n                       depth={props.depth - 1}\n                       numExamples={props.numExamples}\n                       formulaChange={(formula) => childChange(formula, child)}\n                     />))}\n                 <th>{/* empty cell to align with child input */}</th>\n               </React.Fragment>\n               : <script/> }\n            </React.Fragment>\n        );\n    } else {\n        if (isBooleanFormula(props.formula)) {\n            const reals = props.formula.thenChildren.map((child) => (\n                <th key={child.key} colSpan={countWidth(child)} >\n                  <div className='full_cell'>\n                    <ValidatedInput\n                      dummy={false}\n                      placeholder={'Formula'}\n                      isValid={validProg}\n                      onValid={(text) => childChange({...child,\n                                                      prog: parseCheck(text)},\n                                                     child)}\n                      onEmpty={() => childChange({...child,\n                                                  prog: yellow},\n                                                 child)}\n                    />\n                    <RemButton\n                      title={'Remove formula'}\n                      onClick={() => remChild(child)}\n                    />\n                  </div>\n                </th>\n            ));\n\n            const dummy = (\n                <th key={peekKey()} colSpan={1}>\n                  <div className='full_cell'>\n                    <ValidatedInput\n                      dummy={true}\n                      placeholder='Formula'\n                      isValid={validProg}\n                      onValid={(text) => childChange({prog: parseCheck(text),\n                                                      outputs: Array(props.numExamples).fill(yellow),\n                                                      key: takeKey()},\n                                                     {})}\n                    />\n                  </div>\n                </th>\n            );\n\n            return (\n                <React.Fragment>\n                  <th>{/* empty cell to align with parent input */}</th>\n                   <React.Fragment>\n                     {[...reals, dummy]}\n                   </React.Fragment>\n                </React.Fragment>\n            );\n        } else {\n\n            return (\n                <React.Fragment>\n                  <th>{/* empty cell to align with parent input */}</th>\n                </React.Fragment>\n            );\n        }\n    }\n}\n\nfunction SuccinctBody(props) {\n    function remExample(deadExample) {\n        const deadIndex = props.examples.indexOf(deadExample);\n        // Formula -> Formula\n        // removes the output at deadIndex from the given formula and all of its children (if it has any) so stuff works\n        function removeOutputFromFormula(formula) {\n            let outputs = formula.outputs.filter((_, i) => i !== deadIndex);\n\n            if (isBooleanFormula(formula)) {\n                const thenChildren = formula.thenChildren.map(removeOutputFromFormula);\n                return {...formula,\n                        outputs,\n                        thenChildren};\n            } else {\n                return {...formula,\n                        outputs};\n            }\n        }\n\n\n        const aliveExamples = props.examples.filter((example) => example !== deadExample);\n        const alteredForms = props.formulas.map(removeOutputFromFormula);\n        props.examplesFormulasChange(aliveExamples, alteredForms);\n    }\n\n    function exampleChange(newExample, oldExample) {\n        const exists = props.examples.indexOf(oldExample) !== -1;\n\n        if (newExample === dryRun) {\n            return exists;\n        }\n\n        // Formula -> Formula\n        // adds an init output to the given formula and all of its children (if it has any) so stuff works\n        function addAnotherOutputToFormula(formula) {\n            let outputs = [...formula.outputs, yellow];\n\n            if (isBooleanFormula(formula)) {\n                const thenChildren = formula.thenChildren.map(addAnotherOutputToFormula);\n                return {...formula,\n                        outputs,\n                        thenChildren};\n            } else {\n                return {...formula,\n                        outputs};\n            }\n        }\n\n        let alteredExamples, alteredForms;\n        if (exists) {\n            alteredExamples = props.examples.map((example) => example === oldExample ? newExample : example);\n            alteredForms = props.formulas;\n        } else {\n            alteredExamples = [...props.examples, newExample];\n            alteredForms = props.formulas.map(addAnotherOutputToFormula);\n        }\n\n        props.examplesFormulasChange(alteredExamples, alteredForms);\n        return true; // this doesn't actually do anything\n    }\n\n    const reals = props.examples.map((example, i) => (\n          <tr key={example.key}>\n            <td>\n              <RemButton\n                onClick={() => remExample(example)}\n                title={'Remove this example'}\n              />\n            </td>\n            <Inputs\n              dummy={false}\n              inputs={example.inputs}\n              inputsChange={(inputs) => exampleChange({...example, inputs},\n                                                      example)}\n            />\n            <td>{/* empty cell to align with param dummy input */}</td>\n            <Outputs\n              dummy={false}\n              formulas={props.formulas}\n              want={example.want}\n              row={i}\n            />\n            <td>{/* empty cell to align with top level formula dummy input */}</td>\n            <Want\n              dummy={false}\n              wantChange={(want) => exampleChange({...example, want},\n                                                  example)}\n            />\n          </tr>\n    ));\n    \n    const dummy = (\n          <tr key={peekKey(props.paramNames.length)}>\n            <td>{/* empty cell to offset rembutton */}</td>\n            <Inputs\n              dummy={true}\n              inputs={props.paramNames.map((_, i) => ({key: peekKey(i)}))}\n              inputsChange={(inputs) => exampleChange({inputs,\n                                                       want: yellow,\n                                                       key: takeKey()},\n                                                      {})}\n            />\n            <td>{/* empty cell to align with param dummy input */}</td>\n            <Outputs\n              dummy={true}\n              formulas={props.formulas}\n            />\n            <td>{/* empty cell to align with top level formula dummy input */}</td>\n            <Want\n              dummy={true}\n              wantChange={(want) => exampleChange({want,\n                                                   inputs: props.paramNames.map((_) => ({prog: yellow, key: takeKey()})),\n                                                   key: takeKey()},\n                                                  {})}\n            />\n          </tr>\n    );\n\n    return (\n        <tbody>\n          {[...reals, dummy]}\n        </tbody>\n    );\n}\n\nfunction Inputs(props) {\n    function validProg(text) {\n        let goodText = true;\n\n        try {\n            parseCheck(text);\n        } catch(e) {\n            if (e instanceof SyntaxError) {\n                goodText = false;\n            } else {\n                throw e;\n            }\n        }\n\n        return goodText;\n    }\n\n    function inputChange(newInput, oldInput) {\n        let alteredInputs;\n        if (props.dummy) {\n            alteredInputs = props.inputs.map((input) => input === oldInput ? {...newInput, key: takeKey()} : {prog: yellow, key: takeKey()});\n        } else {\n            alteredInputs = props.inputs.map((input) => input === oldInput ? newInput : input);\n        }\n        props.inputsChange(alteredInputs);\n    }\n\n    return (\n        <React.Fragment>\n          {props.inputs.map((input, i) => (\n              <td key={input.key} >\n                <ValidatedInput\n                  dummy={props.dummy}\n                  placeholder={'Input'}\n                  isValid={validProg}\n                  onValid={props.dummy ?\n                           (text) => inputChange({prog: interp(parseCheck(text), initEnv)},\n                                                  input)\n                           :\n                           (text) => inputChange({...input,\n                                                  prog: interp(parseCheck(text), initEnv)},\n                                                 input)}\n                  \n                  onEmpty={() => inputChange({...input,\n                                              prog: yellow},\n                                             input)}\n                />\n              </td>\n          ))}\n        </React.Fragment>\n    );\n}\n\nfunction Outputs(props) {\n    function countWidth(formula) {\n        if (!isBooleanFormula(formula)) {\n            return 1;\n        } else {\n            return formula.thenChildren.reduce((acc, child) => acc + countWidth(child), 2);\n        }\n    }\n\n    if (props.dummy) {\n        return (\n            <React.Fragment>\n            {props.formulas.map((formula) => (\n                <td key={formula.key} colSpan={countWidth(formula)}>{/* empty cell */}</td>\n            ))}\n            </React.Fragment>\n        );\n    } else {\n        return (\n            <React.Fragment>\n              {props.formulas.map((formula) => (\n                  <React.Fragment key={formula.key}>\n                    <TestCell\n                      output={formula.outputs[props.row]}\n                      want={props.want}\n                    />\n                    {isBooleanFormula(formula) ?\n                     <React.Fragment>\n                       <Outputs\n                         formulas={formula.thenChildren}\n                         want={props.want}\n                         row={props.row}\n                       />\n                       <td>{/* empty cell to align with dummy child */}</td>\n                     </React.Fragment>\n                     : <script/> }\n                  </React.Fragment>\n              ))}\n            </React.Fragment>\n        );\n    }\n}\n\nfunction TestCell(props) {\n\n    if (props.output === gray) {\n        return (\n            <td className={'gray'}>\n            </td>\n        );\n    }\n\n    if (props.output === pink) {\n        return (\n            <td className={'pink'}>\n            </td>\n        );\n    }\n\n    if (props.output === yellow) {\n        return (\n            <td className={'yellow'}>\n            </td>\n        );\n    }\n\n    let output = props.output;\n    let want = yellow;\n\n    if (props.want !== yellow) {\n        try {\n            want = interp(props.want, initEnv);\n        } catch (e) {\n            output = e;\n        }\n    }\n\n    let text, error;\n    if (output instanceof Error) {\n        text = output.message;\n        error = true;\n    } else {\n        text = unParse(output);\n        error = false;\n    }\n\n    let img;\n    if (error) {\n        img = <img\n                src={imgPath + 'frowneyface.png'}\n                alt='Error!'\n                style={{float: 'right'}}\n                title={\"Oh no! You got an error!\"}/>;\n    }else if (want === yellow) { // I should make this better\n        img = '';\n    } else if (deepEquals(output, want)) {\n        img =  <img\n                 src={imgPath + 'smileyface.png'}\n                 alt='Yay!'\n                 style={{float: 'right'}}\n                 title={\"Yay! It's right!\"}/>;\n    } else {\n        img = '';\n    }\n\n    return (\n        <td className={'output'}>\n          {text}\n          {img}\n        </td>\n    );\n}\n\nfunction Want(props) {\n    function validProg(text) {\n        let goodText = true;\n\n        try {\n            parseCheck(text);\n        } catch(e) {\n            if (e instanceof SyntaxError) {\n                goodText = false;\n            } else {\n                throw e;\n            }\n        }\n\n        return goodText;\n    }\n\n    return (\n        <td>\n          <ValidatedInput\n            dummy={props.dummy}\n            placeholder={'Want'}\n            isValid={validProg}\n            onValid={(text) => props.wantChange(interp(parseCheck(text), initEnv))}\n            onEmpty={() => props.wantChange(yellow)}\n          />\n        </td>\n    );\n}\n\n/*\n  notes:\n  #inputs === #params\n  #outputs === #examples\n  ---------------------\n  |#inputs !== #outputs| (well it can but not always)\n  ---------------------\n*/\n\nclass App extends React.Component {\n    constructor(props){\n        super(props);\n        let tables = [{examples: [{inputs: [{prog: yellow, key: takeKey()}], want: yellow, key: takeKey()}],\n                       formulas: [{prog: yellow, outputs: [yellow], key: takeKey()}],\n                       params: [{name: yellow, key: takeKey()}],\n                       name: yellow,\n                       key: takeKey()}];\n        this.state = {tables};\n\n        this.programChange = this.programChange.bind(this);\n    }\n\n    calculate(program) {\n        function makeLookup(table) {\n            function lookup(args) {\n                if (args.length !== table.params.length) {\n                    throw new Error('Arity Mismatch, expected ' + table.params.length + ' argument' + (table.params.length === 1 ? '' : 's'));\n                }\n\n                let expr = table.examples.reduce((acc, example) => {\n                    if (acc !== undefined) {\n                        return acc;\n                    }\n\n                    // I have no idea what should happen if this is called on a table with no params\n                    if (example.inputs.reduce((acc, input, i) => {\n                        return acc && deepEquals(input.prog, args[i]);\n                    }, true)) {\n                        if (example.want === yellow) {\n                            throw new ReferenceError(`(${table.name} ${args.map(unParse).join(' ')}) doesn't have a want`);\n                        } else {\n                            return example.want;\n                        }\n                    }\n\n                    return undefined;\n                }, undefined);\n\n                if (expr === undefined) {\n                    // it's like a reference error in the super meta table language\n                    throw new ReferenceError(args.map(unParse).join() + ' is not an example in ' + table.name);\n                }\n\n                return expr;\n            }\n\n            return lookup;\n        }\n\n        let lookups = program.map((table) => ({name: table.name, binding: {value: makeLookup(table), type: RFUNCT_T}}));\n        let globalEnv = [...initEnv, ...lookups];\n\n        function calcTable(table) {\n            function calcFormula(formula, examples) {\n                let outputs = examples.map((example) => {\n                    if (example === gray) {\n                        return gray;\n                    } else if (example === pink) {\n                        return pink;\n                    } else if (!example.inputs.every((input) => input.prog !== yellow) || formula.prog === yellow) { // if any inputs or the formula aren't initialized\n                        return yellow;\n                    }\n\n                    let localEnv = table.params.map((param, i) => ({name: param.name, binding: example.inputs[i].prog}));\n                    let env = [...globalEnv, ...localEnv];\n\n                    try {\n                        var output = interp(formula.prog, env);\n                    } catch (e) {\n                        output = e;\n                    }\n\n                    return output;\n                });\n\n                if (allBools(outputs) || (formula.thenChildren !== undefined && formula.thenChildren.length !== 0)) {\n                    function maybeSpecial(example, output) {\n                        if (example === gray || output.value === false)\n                            return gray;\n                        else if (typeof output.value !== 'boolean')\n                            return pink;\n                        else\n                            return example;\n                    }\n\n                    if (formula.thenChildren === undefined) {\n                        var thenChildren = [];\n                    } else {\n                        let subExamples = examples.map((example, i) => maybeSpecial(example, outputs[i]));\n                        thenChildren = formula.thenChildren.map((formula) => calcFormula(formula, subExamples));\n                    }\n\n                    return {...formula,\n                            outputs,\n                            thenChildren};\n                } else {\n                    let newFormula = {...formula,\n                                      outputs};\n                    delete newFormula.thenChildren;\n                    return newFormula;\n                }\n            }\n\n            if (table.name === yellow || !table.params.every((param) => param.name !== yellow)) { // if the table or any of the table's parameters don't have a name yet, don't calculate\n                // I should probably change this at some point, as it is it pretty much overwrites all outputs if a new parameter is added, although I guess it would do that anyway because of how init inputs are treated\n                let formulas = table.formulas.map((formula) => ({...formula, outputs: Array(table.examples.length).fill(yellow)}));\n                return {...table,\n                        formulas};\n            } else {\n                let formulas = table.formulas.map((formula) => calcFormula(formula, table.examples));\n                return {...table,\n                        formulas};\n            }\n\n        }\n\n        return program.map(calcTable);\n    }\n\n    programChange(newProg) {\n        let calkedProg = this.calculate(newProg);\n        console.log(calkedProg);\n        //console.log('next key: ', peekKey());\n        //console.log(toBSL(calkedProg));\n        this.setState((state) => {\n            return {tables: calkedProg};\n        });\n    }\n\n    render(){\n        return (\n            <div>\n              <Succinct\n                tables={this.state.tables}\n                programChange={this.programChange}\n              />\n              <textarea\n                rows={10}\n                cols={50}\n                className='bsl_io'\n                readOnly={true}\n                value={toBSL(this.state.tables)}\n              />\n            </div>\n        );\n    }\n}\n\nexport default App;\n","// This optional code is used to register a service worker.\n// register() is not called by default.\n\n// This lets the app load faster on subsequent visits in production, and gives\n// it offline capabilities. However, it also means that developers (and users)\n// will only see deployed updates on subsequent visits to a page, after all the\n// existing tabs open on the page have been closed, since previously cached\n// resources are updated in the background.\n\n// To learn more about the benefits of this model and instructions on how to\n// opt-in, read https://bit.ly/CRA-PWA\n\nconst isLocalhost = Boolean(\n  window.location.hostname === 'localhost' ||\n    // [::1] is the IPv6 localhost address.\n    window.location.hostname === '[::1]' ||\n    // 127.0.0.1/8 is considered localhost for IPv4.\n    window.location.hostname.match(\n      /^127(?:\\.(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)){3}$/\n    )\n);\n\nexport function register(config) {\n  if (process.env.NODE_ENV === 'production' && 'serviceWorker' in navigator) {\n    // The URL constructor is available in all browsers that support SW.\n    const publicUrl = new URL(process.env.PUBLIC_URL, window.location.href);\n    if (publicUrl.origin !== window.location.origin) {\n      // Our service worker won't work if PUBLIC_URL is on a different origin\n      // from what our page is served on. This might happen if a CDN is used to\n      // serve assets; see https://github.com/facebook/create-react-app/issues/2374\n      return;\n    }\n\n    window.addEventListener('load', () => {\n      const swUrl = `${process.env.PUBLIC_URL}/service-worker.js`;\n\n      if (isLocalhost) {\n        // This is running on localhost. Let's check if a service worker still exists or not.\n        checkValidServiceWorker(swUrl, config);\n\n        // Add some additional logging to localhost, pointing developers to the\n        // service worker/PWA documentation.\n        navigator.serviceWorker.ready.then(() => {\n          console.log(\n            'This web app is being served cache-first by a service ' +\n              'worker. To learn more, visit https://bit.ly/CRA-PWA'\n          );\n        });\n      } else {\n        // Is not localhost. Just register service worker\n        registerValidSW(swUrl, config);\n      }\n    });\n  }\n}\n\nfunction registerValidSW(swUrl, config) {\n  navigator.serviceWorker\n    .register(swUrl)\n    .then(registration => {\n      registration.onupdatefound = () => {\n        const installingWorker = registration.installing;\n        if (installingWorker == null) {\n          return;\n        }\n        installingWorker.onstatechange = () => {\n          if (installingWorker.state === 'installed') {\n            if (navigator.serviceWorker.controller) {\n              // At this point, the updated precached content has been fetched,\n              // but the previous service worker will still serve the older\n              // content until all client tabs are closed.\n              console.log(\n                'New content is available and will be used when all ' +\n                  'tabs for this page are closed. See https://bit.ly/CRA-PWA.'\n              );\n\n              // Execute callback\n              if (config && config.onUpdate) {\n                config.onUpdate(registration);\n              }\n            } else {\n              // At this point, everything has been precached.\n              // It's the perfect time to display a\n              // \"Content is cached for offline use.\" message.\n              console.log('Content is cached for offline use.');\n\n              // Execute callback\n              if (config && config.onSuccess) {\n                config.onSuccess(registration);\n              }\n            }\n          }\n        };\n      };\n    })\n    .catch(error => {\n      console.error('Error during service worker registration:', error);\n    });\n}\n\nfunction checkValidServiceWorker(swUrl, config) {\n  // Check if the service worker can be found. If it can't reload the page.\n  fetch(swUrl)\n    .then(response => {\n      // Ensure service worker exists, and that we really are getting a JS file.\n      const contentType = response.headers.get('content-type');\n      if (\n        response.status === 404 ||\n        (contentType != null && contentType.indexOf('javascript') === -1)\n      ) {\n        // No service worker found. Probably a different app. Reload the page.\n        navigator.serviceWorker.ready.then(registration => {\n          registration.unregister().then(() => {\n            window.location.reload();\n          });\n        });\n      } else {\n        // Service worker found. Proceed as normal.\n        registerValidSW(swUrl, config);\n      }\n    })\n    .catch(() => {\n      console.log(\n        'No internet connection found. App is running in offline mode.'\n      );\n    });\n}\n\nexport function unregister() {\n  if ('serviceWorker' in navigator) {\n    navigator.serviceWorker.ready.then(registration => {\n      registration.unregister();\n    });\n  }\n}\n","import React from 'react';\nimport ReactDOM from 'react-dom';\nimport './index.css';\nimport App from './App';\nimport * as serviceWorker from './serviceWorker';\n\nReactDOM.render(<App />, document.getElementById('root'));\n\n// If you want your app to work offline and load faster, you can change\n// unregister() to register() below. Note this comes with some pitfalls.\n// Learn more about service workers: https://bit.ly/CRA-PWA\nserviceWorker.unregister();\n"],"sourceRoot":""}