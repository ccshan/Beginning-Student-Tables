{"version":3,"sources":["App.js","serviceWorker.js","index.js"],"names":["RVAR_T","RAPP_T","RFUNCT_T","RNUM_T","RBOOL_T","RSTRING_T","RLIST_T","RSYM_T","initEnv","name","binding","type","value","args","env","argVals","map","elem","interp","forEach","cur","typeCheck","reduce","acc","length","firstVal","secondVal","car","cdr","Error","a","d","arg","reverse","prog","thirdVal","isnull","interpArgs","val","parse","text","varRE","numRE","boolRE","strRE","test","numStr","match","rest","slice","trim","boolStr","matches","parseFunct","funct","parseArg","concat","Object","toConsumableArray","parseQ","symRE","listRE","listArr","num","bool","str","sym","SyntaxError","variable","undefined","ReferenceError","lookup","TypeError","unParse","join","parseCheck","parsed","typeString","tableToBSL","table","inputToBSL","params","param","body","formulas","formulaToBSL","check_expects","examples","example","inputs","input","want","formula","isBooleanFormula","thenChildren","yellow","gray","pink","dryRun","yo","imgPath","keyCount","allBools","progs","every","outputs","takeKey","peekKey","lookahead","deepEquals","proga","progb","functCheck","argCheck","arga","i","AddButton","props","react_default","createElement","style","src","alt","title","onClick","RemButton","className","ValidatedInput","_this","classCallCheck","this","possibleConstructorReturn","getPrototypeOf","call","state","textChange","bind","assertThisInitialized","e","target","setState","isValid","onValid","dummy","onEmpty","size","placeholder","Math","max","onChange","React","Component","Succinct","tableChange","newTab","oldTab","alteredTabs","tables","programChange","key","App_ValidatedInput","modTab","tableVars","filter","propTab","paramVars","validName","objectSpread","deadTab","aliveTabs","remTable","SuccinctTab","tableNames","tableKey","formulasChange","SuccinctHead","paramsExamplesChange","SuccinctBody","paramNames","examplesChange","validProg","isgood","formulaChange","newForm","oldForm","alteredForms","indexOf","form","countWidth","child","abyss","maxDepth","curMax","numParams","reals","colSpan","deadForm","aliveForms","remFormula","_","children","countUp","depth","DepictFormula","numExamples","Parameters","validParam","modParam","paramChange","newParam","alteredParams","alteredExamples","deadParam","deadIndex","aliveParams","modExamples","remParam","Fragment","childChange","newChild","modChild","deadChild","aliveChildren","remChild","Array","fill","exampleChange","newExample","oldExample","exists","deadExample","aliveExamples","remExample","Inputs","inputsChange","Outputs","row","Want","wantChange","goodText","inputChange","newInput","oldInput","alteredInputs","TestCell","output","error","img","message","float","App","_this2","program","makeLookup","expr","INterped","lookups","globalEnv","calcFormula","localEnv","subExamples","maybeSpecial","newFormula","newProg","calkedProg","calculate","console","log","rows","cols","readOnly","Boolean","window","location","hostname","ReactDOM","render","src_App_0","document","getElementById","navigator","serviceWorker","ready","then","registration","unregister"],"mappings":"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","file":"static/js/main.404f940e.chunk.js","sourcesContent":["import React from 'react';\nimport './App.css';\n\n\n/****************\n   Interpreter\n****************/\n\nconst RVAR_T =    0;\nconst RAPP_T =    1;\nconst RFUNCT_T =   2;\nconst RNUM_T =    3;\nconst RBOOL_T =   4;\nconst RSTRING_T = 5;\nconst RLIST_T =   6;\nconst RSYM_T =    7;\n\nconst initEnv = [\n    // functions\n    {name: '+', binding: {type: RFUNCT_T,\n                          value: plus}},\n    {name: '-', binding: {type: RFUNCT_T,\n                          value: minus}},\n    {name: '*', binding: {type: RFUNCT_T,\n                          value: times}},\n    {name: '/', binding: {type: RFUNCT_T,\n                          value: divide}},\n    {name: 'car', binding: {type: RFUNCT_T,\n                            value: car}},\n    {name: 'first', binding: {type: RFUNCT_T,\n                              value: car}},\n    {name: 'cdr', binding: {type: RFUNCT_T,\n                            value: cdr}},\n    {name: 'rest', binding: {type: RFUNCT_T,\n                             value: cdr}},\n    {name: 'cons', binding: {type: RFUNCT_T,\n                             value: cons}},\n    {name: 'list', binding: {type: RFUNCT_T,\n                             value: list}},\n    {name: 'not', binding: {type: RFUNCT_T,\n                            value: not}},\n    {name: 'and', binding: {type: RFUNCT_T,\n                            value: and}},\n    {name: 'or', binding: {type: RFUNCT_T,\n                           value: or}},\n    {name: 'if', binding: {type: RFUNCT_T,\n                           value: rif}},\n    {name: 'eqv?', binding: {type: RFUNCT_T,\n                             value: iseqv}},\n    {name: 'null?', binding: {type: RFUNCT_T,\n                              value: isnull}},\n    {name: 'empty?', binding: {type: RFUNCT_T,\n                               value: isnull}},\n    {name: '=', binding: {type: RFUNCT_T,\n                          value: equalsign}},\n    {name: '>', binding: {type: RFUNCT_T,\n                          value: gtsign}},\n    {name: '>=', binding: {type: RFUNCT_T,\n                           value: gesign}},\n    {name: '<', binding: {type: RFUNCT_T,\n                          value: ltsign}},\n    {name: '<=', binding: {type: RFUNCT_T,\n                           value: lesign}},\n    // constants\n    {name: 'true', binding: {type: RBOOL_T,\n                             value: true}},\n    {name: 'false', binding: {type: RBOOL_T,\n                              value: false}},\n    {name: 'null', binding: {type: RLIST_T,\n                             value: null}},\n    {name: 'empty', binding: {type: RLIST_T,\n                              value: null}},\n];\n\n// String -> {prog: Program, rest: String}\n// parses all expressions except quoted expressions\nfunction parse(text) {\n    const varRE = /^[a-zA-Z+\\-*/?=><]+/; // change me\n    const appRE = /^\\(/;\n    const numRE = /^-?\\d+/; // this one doesn't permit fractions\n    const boolRE = /^#[tf]/;\n    const strRE = /^\"[^\"]*\"/;\n    const quoteRE = /^'/;\n\n    if (numRE.test(text)) {\n        let matches = text.match(numRE);\n        let numStr = matches[0];\n        let rest = text.slice(numStr.length).trim();\n        let num = {value: +numStr, type: RNUM_T};\n\n        return {prog: num, rest: rest};\n    } else if (varRE.test(text)) {\n        let matches = text.match(varRE);\n        let name = matches[0];\n        let rest = text.slice(name.length).trim();\n        let variable = {value: name, type: RVAR_T};\n\n        return {prog: variable, rest: rest};\n\n\n    } else if (boolRE.test(text)) {\n        let matches = text.match(boolRE);\n        let boolStr = matches[0];\n        let rest = text.slice(2).trim();\n        let bool = {value: boolStr === '#t', type: RBOOL_T};\n\n        return {prog: bool, rest: rest};\n\n    } else if (strRE.test(text)) {\n        let matches = text.match(strRE);\n        let str = {value: matches[0], type: RSTRING_T};\n        let rest = text.slice(matches[0].length).trim();\n\n        return {prog: str, rest: rest};\n\n    } else if (appRE.test(text)) {\n        text = text.slice(1).trim(); // remove open paren\n        let parseFunct = parse(text); // parse function\n        let funct = parseFunct.prog; // get function\n        text = parseFunct.rest; // get past function\n        let args = [];\n\n        while (text[0] !== ')') {\n            let parseArg = parse(text);\n            args = [...args, parseArg.prog];\n            text = parseArg.rest;\n        }\n\n        let app = {value: {funct: funct, args: args}, type: RAPP_T};\n        let rest = text.slice(1).trim(); // remove close paren\n\n        return {prog: app, rest: rest};\n\n    } else if (quoteRE.test(text)) {\n        return parseQ(text);\n    }\n\n    throw new SyntaxError('Invalid Syntax: \"' + text + '\"');\n}\n\n// String -> {prog: Program, rest: String}\n// parses quoted expressions\nfunction parseQ(text) {\n    const symRE = /^'?[a-zA-Z+\\-*/?=><#\"]+/; // change me\n    const listRE = /^'?\\s*\\(/;\n    const numRE = /^'?-?\\d+/; // this one doesn't permit fractions\n    const boolRE = /^#[tf]/;\n    const strRE = /^\"[^\"]*\"/;\n\n\n    if (listRE.test(text)) {\n        text = text.slice(text.match(listRE)[0].length).trim(); // remove quote, open paren\n        let listArr = [];\n\n        while (text[0] !== ')') {\n            let cur = parseQ(text);\n            listArr = [cur.prog, ...listArr]; // listArr is constructed backwards\n            text = cur.rest;\n        }\n\n        let rest = text.slice(1).trim();\n        let prog = listArr.reduce((acc, cur) => ({value: {a: cur, d: acc}, type: RLIST_T}), {value: null, type: RLIST_T}); // turn listArr into an Rlist\n\n        return {prog: prog, rest: rest};\n\n    } else if (numRE.test(text)) {\n        let matches = text.match(numRE);\n        let numStr = matches[0];\n        let rest = text.slice(numStr.length).trim();\n        let num = {value: +numStr, type: RNUM_T};\n\n        return {prog: num, rest: rest};\n\n    } else if (boolRE.test(text)) {\n        let matches = text.match(boolRE);\n        let boolStr = matches[0];\n        let rest = text.slice(2).trim();\n        let bool = {value: boolStr === '#t', type: RBOOL_T};\n\n        return {prog: bool, rest: rest};\n\n    } else if (strRE.test(text)) {\n        let matches = text.match(strRE);\n        let str = {value: matches[0], type: RSTRING_T};\n        let rest = text.slice(matches[0].length).trim();\n\n        return {prog: str, rest: rest};\n\n    } else if (symRE.test(text)) {\n        let matches = text.match(symRE);\n        let value = matches[0];\n        value = value[0] === '\\'' ? value : '\\'' + value;\n        let sym = {value: value, type: RSYM_T};\n        let rest = text.slice(matches[0].length).trim();\n\n        return {prog: sym, rest: rest};\n    }\n\n    throw new SyntaxError('Invalid Syntax: \"' + text + '\"');\n}\n\n/***\n    Environment: [Variable]\n    Variable:    {name:    String,\n    binding: Program}\n***/\n\n// Program -> Environment -> Program\nfunction interp(prog, env) {\n    function lookup(name) {\n        let val = env.reduce((acc, variable) => {\n            if (acc !== undefined) {\n                return acc;\n            }\n\n            return variable.name === name ? variable.binding : undefined;\n        }, undefined);\n\n        if (val === undefined){\n            throw new ReferenceError(name + ' isn\\'t defined');\n        }\n\n        return val;\n    }\n\n    switch(prog.type) {\n    case RNUM_T:\n        return prog;\n    case RBOOL_T:\n        return prog;\n    case RSTRING_T:\n        return prog;\n    case RLIST_T:\n        return prog;\n    case RSYM_T:\n        return prog;\n    case RVAR_T:\n        return interp(lookup(prog.value), env);\n    case RFUNCT_T:\n        return prog;\n    case RAPP_T:\n        let args = prog.value.args;\n        let funct = interp(prog.value.funct, env);\n\n        typeCheck(funct, RFUNCT_T);\n\n        return funct.value(args, env);\n\n    default:\n        throw new TypeError(\"Unknown Type \" + prog.value);\n    }\n}\n\n// Program -> String\nfunction unParse(prog) {\n    switch (prog.type) {\n    case RNUM_T:\n        return prog.value;\n    case RBOOL_T:\n        return '#' + (prog.value ? 'true' : 'false');\n    case RSTRING_T:\n        return prog.value;\n    case RLIST_T:\n        if (prog.value === null) {\n            return '\\'()';\n        } else {\n            return `(cons ${unParse(prog.value.a)} ${unParse(prog.value.d)})`;\n        }\n    case RSYM_T:\n        return prog.value;\n    case RVAR_T:\n        return prog.value;\n    case RFUNCT_T:\n        return 'function';\n    case RAPP_T:\n        return `(${unParse(prog.value.funct)} ${prog.value.args.map(unParse).join(' ')})`;\n    default:\n        return 'error or something';\n    }\n}\n\n// String -> Program\n// parses text and checks for syntax errors based on what's returned\nfunction parseCheck(text) {\n    let parsed = parse(text);\n\n    switch (parsed.rest) {\n    case '':\n        break;\n    default:\n        throw new SyntaxError('Parsing Error');\n    }\n\n    return parsed.prog;\n}\n\n// Program -> Number -> Side Effect Maybe\nfunction typeCheck(prog, type){\n    let typeString = '';\n    switch (type) {\n    case RVAR_T:\n        typeString = 'variable';\n        break;\n    case RAPP_T:\n        typeString = 'application';\n        break;\n    case RFUNCT_T:\n        typeString = 'function';\n        break;\n    case RNUM_T:\n        typeString = 'number';\n        break;\n    case RBOOL_T:\n        typeString = 'boolean';\n        break;\n    case RSTRING_T:\n        typeString = 'string';\n        break;\n    case RLIST_T:\n        typeString = 'list';\n        break;\n    case RSYM_T:\n        typeString = 'symbol';\n        break;\n    default:\n        typeString = '???';\n    }\n\n    if (prog.type !== type){\n        throw new TypeError(unParse(prog) + ' ain\\'t a ' + typeString);\n    }\n}\n\nfunction plus(args, env) {\n    let argVals = args.map((elem) => interp(elem, env));\n    argVals.forEach((cur) => typeCheck(cur, RNUM_T));\n\n    return argVals.reduce((acc, cur) => {\n        return {value: acc.value + cur.value,\n                type: RNUM_T};\n    });\n}\nfunction minus(args, env) {\n    let argVals = args.map((elem) => interp(elem, env));\n    argVals.forEach((cur) => typeCheck(cur, RNUM_T));\n\n    return argVals.reduce((acc, cur) => {\n        return {value: acc.value - cur.value,\n                type: RNUM_T};\n    });\n}\nfunction times(args, env) {\n    let argVals = args.map((elem) => interp(elem, env));\n    argVals.forEach((cur) => typeCheck(cur, RNUM_T));\n\n    return argVals.reduce((acc, cur) => {\n        return {value: acc.value * cur.value,\n                type: RNUM_T};\n    });\n}\nfunction divide(args, env) {\n    if (args.length === 1) {\n        let firstVal = interp(args[0], env);\n\n        typeCheck(firstVal, RNUM_T);\n\n        return {value: 1 / firstVal.value,\n                type: RNUM_T};\n    } else if (args.length === 2) {\n        let firstVal = interp(args[0], env);\n        let secondVal = interp(args[1], env);\n\n        typeCheck(firstVal, RNUM_T);\n        typeCheck(secondVal, RNUM_T);\n\n        return {value: firstVal.value / secondVal.value,\n                type: RNUM_T};\n    }\n\n    args.forEach((cur) => typeCheck(cur, RNUM_T));\n    return {value: false, type: RBOOL_T};\n}\nfunction car(args, env) {\n    if (args.length !== 1) {\n        throw new Error('arity mismatch');\n    }\n\n    let firstVal = interp(args[0], env);\n\n    typeCheck(firstVal, RLIST_T);\n\n    return firstVal.value.a;\n}\nfunction cdr(args, env) {\n    if (args.length !== 1) {\n        throw new Error('arity mismatch');\n    }\n\n    let firstVal = interp(args[0], env);\n\n    typeCheck(firstVal, RLIST_T);\n\n    return firstVal.value.d;\n}\nfunction cons(args, env) {\n    if (args.length !== 2) {\n        throw new Error('arity mismatch');\n    }\n\n    let firstVal = interp(args[0], env);\n    let secondVal = interp(args[1], env);\n\n    // because BSL\n    typeCheck(secondVal, RLIST_T);\n\n    return {value: {a: firstVal, d: secondVal},\n            type: RLIST_T};\n}\nfunction list(args, env) {\n    if (args.length === 0) {\n        throw new Error('arity mismatch');\n    }\n\n    let interpArgs = args.map((arg) => interp(arg, env));\n\n    return interpArgs.reverse().reduce((acc, arg) => ({value: {a: arg, d: acc},\n                                                       type: RLIST_T}),\n                                       {value: null,\n                                        type: RLIST_T});\n}\nfunction not(args, env) {\n    if (args.length !== 1) {\n        throw new Error('arity mismatch');\n    }\n\n    let firstVal = interp(args[0], env);\n\n    return {value: firstVal.value === false,\n            type: RBOOL_T};\n}\nfunction iseqv(args, env) {\n    if (args.length !== 2) {\n        throw new Error('arity mismatch');\n    }\n\n    let firstVal = interp(args[0], env);\n    let secondVal = interp(args[1], env);\n\n    return {value: firstVal.value === secondVal.value,\n            type: RBOOL_T};\n}\nfunction and(args, env) {\n    let interpArgs = args.map((prog) => interp(prog, env));\n\n    return interpArgs.reduce((acc, cur) => {\n        return acc.value !== false ? cur : {value: false, type: RBOOL_T};\n    }, {value: true, type: RBOOL_T});\n\n}\nfunction or(args, env) {\n    let interpArgs = args.map((prog) => interp(prog, env));\n\n    return interpArgs.reduce((acc, cur) => {\n        return acc.value !== false ? acc : cur;\n    }, {value: true, type: RBOOL_T});\n\n}\nfunction rif(args, env) {\n    if (args.length !== 3) {\n        throw new Error('arity mismatch');\n    }\n\n    let firstVal = interp(args[0], env);\n    let secondVal = interp(args[1], env);\n    let thirdVal = interp(args[2], env);\n\n    typeCheck(firstVal, RBOOL_T);\n\n    return firstVal.value ? secondVal : thirdVal;\n}\nfunction isnull(args, env) {\n    if (args.length !== 1) {\n        throw new Error('arity mismatch');\n    }\n\n    let firstVal = interp(args[0], env);\n\n    return {value: firstVal.value === null && firstVal.type === RLIST_T,\n            type: RBOOL_T};\n}\nfunction equalsign(args, env) {\n    let interpArgs = args.map((elem) => interp(elem, env));\n    interpArgs.forEach((cur) => typeCheck(cur, RNUM_T));\n\n    let val = interpArgs.reduce((acc, cur) => {\n\n        if (acc.value === false) {\n            return {value: false, type: RBOOL_T};\n        }\n\n        return acc.value===cur.value ? acc : {value: false, type: RBOOL_T};\n    });\n\n    if (val.value === false){\n        return val;\n    } else {\n        return {value: true, type: RBOOL_T};\n    }\n}\nfunction gtsign(args, env) {\n    let interpArgs = args.map((elem) => interp(elem, env));\n    interpArgs.forEach((cur) => typeCheck(cur, RNUM_T));\n\n    let val = interpArgs.reduce((acc, cur) => {\n\n        if (acc.value === false) {\n            return {value: false, type: RBOOL_T};\n        }\n\n        return acc.value > cur.value ? acc : {value: false, type: RBOOL_T};\n    });\n\n    if (val.value === false){\n        return val;\n    } else {\n        return {value: true, type: RBOOL_T};\n    }\n}\nfunction gesign(args, env) {\n    let interpArgs = args.map((elem) => interp(elem, env));\n    interpArgs.forEach((cur) => typeCheck(cur, RNUM_T));\n\n    let val = interpArgs.reduce((acc, cur) => {\n\n        if (acc.value === false) {\n            return {value: false, type: RBOOL_T};\n        }\n\n        return acc.value >= cur.value ? acc : {value: false, type: RBOOL_T};\n    });\n\n    if (val.value === false){\n        return val;\n    } else {\n        return {value: true, type: RBOOL_T};\n    }\n}\nfunction ltsign(args, env) {\n    let interpArgs = args.map((elem) => interp(elem, env));\n    interpArgs.forEach((cur) => typeCheck(cur, RNUM_T));\n\n    let val = interpArgs.reduce((acc, cur) => {\n\n        if (acc.value === false) {\n            return {value: false, type: RBOOL_T};\n        }\n\n        return acc.value < cur.value ? acc : {value: false, type: RBOOL_T};\n    });\n\n    if (val.value === false){\n        return val;\n    } else {\n        return {value: true, type: RBOOL_T};\n    }\n}\nfunction lesign(args, env) {\n    let interpArgs = args.map((elem) => interp(elem, env));\n    interpArgs.forEach((cur) => typeCheck(cur, RNUM_T));\n\n    let val = interpArgs.reduce((acc, cur) => {\n\n        if (acc.value === false) {\n            return {value: false, type: RBOOL_T};\n        }\n\n        return acc.value <= cur.value ? acc : {value: false, type: RBOOL_T};\n    });\n\n    if (val.value === false){\n        return val;\n    } else {\n        return {value: true, type: RBOOL_T};\n    }\n}\n\n/**************************************\n    Thing that Turns Tables Into BSL\n**************************************/\n\n// [Table] -> String\nfunction toBSL(program) {\n    return program.map(tableToBSL).join('\\n\\n\\n');\n}\n\n// Table -> String\nfunction tableToBSL(table) {\n    let name = inputToBSL(table.name);\n    let params = table.params.map((param) => inputToBSL(param.name)).join(' ');\n    let body = table.formulas.map(formulaToBSL).join('\\n');\n    let check_expects = table.examples.map((example) => (\n        `(check-expect (${name} ${example.inputs.map((input) => inputToBSL(input.prog)).join(' ')}) ${inputToBSL(example.want)})`\n    )).join('\\n');\n\n    return `(define (${name} ${params})\\n${body})\\n\\n${check_expects}`;\n}\n\n// Formula -> String\nfunction formulaToBSL(formula) {\n    if (isBooleanFormula(formula)) {\n        return `(cond [${inputToBSL(formula.prog)} ${formula.thenChildren.map(formulaToBSL).join(' ')}])`;\n    } else {\n        return inputToBSL(formula.prog);\n    }\n}\n\n// Input (yellow or string or program) -> String\nfunction inputToBSL(input) {\n    if (input === yellow) { // init\n        return '...';\n    } else if (typeof input === 'string') { // name\n        return input;\n    } else { // program\n        return unParse(input);\n    }\n}\n\n/*****************************\n  Universal Constants I Want\n*****************************/\n// value to put in child formulas that don't have an output for that row\nconst gray = {gray: 'gray'};\n// value to put in child formulas that have an error output for that row (non-boolean and non-gray)\nconst pink = {pink: 'pink'};\n// value that indicates an uninitialized input\nconst yellow = {yellow: 'yellow'};\n// value to indicate a dry run, i.e. don't actually change the underlying structure, just say\n// if the given value exists or not\nconst dryRun = {yo: 'don\\'t actually change anything'};\n// image path\nconst imgPath = './images/';\n\nlet keyCount = 0;\n\n\n/*********************\n   Functions I Want\n*********************/\n// [Program] -> Boolean\n// returns true if progs has at least one member and all of its members are boooleans\n//    otherwise returns false\nfunction allBools(progs){\n    if (progs.length === 0) {\n        return false;\n    }\n\n    return progs.every((prog) => prog.type === RBOOL_T || prog === gray);\n}\n\nfunction isBooleanFormula(formula) {\n    return allBools(formula.outputs) || formula.thenChildren !== undefined;\n}\n\n// Number\n// returns a unique key\nfunction takeKey() {\n    return keyCount++;\n}\n\n// [Number] -> Number (the brackets here mean optional, not array)\n// returns current key without changing it\n// shoud be used to look at current state of key without actually taking it\n// optionally takes a number as an argument, in which case it returns the key that number\n// of steps ahead of the current key\nfunction peekKey(lookahead) {\n    if (lookahead === undefined) {\n        return keyCount;\n    } else {\n        return keyCount + lookahead;\n    }\n}\n\n// Program -> Program -> Boolean\n// checks if two programs are equivalent, recurs on lists and applications\n// may not quite work on functions because I use js functions, not data represented closures or something\n//    thus 2 functions are only equal if they're a reference to the same object\nfunction deepEquals(proga, progb) {\n    if (proga.type !== progb.type) {\n        return false;\n    }\n\n    if (proga.type === RLIST_T) {\n        if (proga.value === null || progb.value === null) {\n            return proga.value === progb.value;\n        }\n        return deepEquals(proga.value.a, progb.value.a) && deepEquals(proga.value.d, progb.value.d);\n    }\n\n    // this case will prolly never even happen...\n    if (proga.type === RAPP_T) {\n        if (proga.value.args.length !== progb.value.args.length) {\n            return false;\n        }\n        let functCheck = deepEquals(proga.value.funct, progb.value.funct);\n        let argCheck = proga.value.args.map((arga, i) => deepEquals(arga, progb.value.args[i])).every((elem) => elem);\n        return functCheck && argCheck;\n    }\n\n    return proga.value === progb.value;\n}\n\n/*********************\n   React Components\n*********************/\n\n/*** Buttons ***/\n// Button that probably adds something\nfunction AddButton(props){\n    return (\n        <input\n          type={'image'}\n          style={props.style}\n          src={imgPath + 'plus.png'}\n          alt='Add'\n          title={props.title}\n          onClick={props.onClick}/>\n    );\n}\n\n// Button that probably removes something\nfunction RemButton(props){\n    return (\n        <div className='cross_button'>\n          <input\n            type={'image'}\n            style={props.style}\n            src={'./images/smallCross.png'}\n            alt='Remove'\n            title={props.title}\n            onClick={props.onClick}/>\n        </div>\n    );\n}\n\n/*** Inputs ***/\nclass ValidatedInput extends React.Component {\n    constructor(props) {\n        super(props);\n        this.state = {text: ''};\n\n        this.textChange = this.textChange.bind(this);\n    }\n\n    textChange(e) {\n        let text = e.target.value;\n\n        this.setState((state) => ({text}));\n\n        if (this.props.isValid(text)) {\n            this.props.onValid(text);\n        } else if (text === '' && !this.props.dummy) {\n            this.props.onEmpty();\n        }\n\n    }\n\n    render() {\n        let className;\n        if (this.props.dummy) {\n            className = 'dummy_input';\n        } else if (this.props.isValid(this.state.text)) {\n            className = 'valid_input';\n        } else if (this.state.text === '') {\n            className = 'empty_input';\n        } else {\n            className = 'invalid_input';\n        }\n        \n        let size;\n        if (this.state.text.length === 0)\n            size = this.props.placeholder.length;\n        else\n            size = Math.max(this.state.text.length + 2, 4);\n\n        return (\n            <input\n              className={className}\n              size={size}\n              placeholder={this.props.placeholder}\n              type={'text'}\n              value={this.state.text}\n              onChange={this.textChange}\n            />\n        );\n    }\n}\n\n/*** Table Sections ***/\n// let's put everything in one table woo\nfunction Succinct(props) {\n\n    function tableChange(newTab, oldTab) {\n        let alteredTabs = props.tables.map((table) => table === oldTab ? newTab : table);\n        props.programChange(alteredTabs);\n    }\n\n    function addTable(name) {\n        const tableKey = takeKey();\n        if (name === undefined) {\n            name = yellow;\n        }\n        name = yellow;\n\n        let newTab = {examples: [{inputs: [{prog: yellow, key: takeKey()}], want: yellow, key: takeKey()}],\n                      formulas: [{prog: yellow, outputs: [yellow], key: takeKey()}],\n                      params: [{name: yellow, key: takeKey()}],\n                      name: name,\n                      key: tableKey};\n\n        props.programChange([...props.tables, newTab]);\n    }\n\n    function remTable(deadTab) {\n        let aliveTabs = props.tables.filter((table) => table !== deadTab);\n        props.programChange(aliveTabs);\n    }\n\n    // String -> Boolean\n    function validName(text, modTab) {\n        function lookup(name, env) {\n            return env.reduce((acc, variable) => {\n                if (acc) {\n                    return true;\n                }\n\n                return variable.name === name;\n\n            }, false);\n        }\n\n        let tableVars = props.tables.filter((table) => table !== modTab).map((propTab) => ({name: propTab.name, binding: null}));\n        // TODO: change this call to reflect how params work now\n        //       also make this not awful\n        let paramVars = modTab.params.map((param) => ({name: param, binding: null}));\n        let env = [...initEnv, ...tableVars, ...paramVars];\n\n        const varRE = /^[a-zA-Z+\\-*/?=><]+$/; // change me\n\n        return varRE.test(text) && !lookup(text, env);\n    }\n\n    return (\n        <div>\n          {[...props.tables.map((table) => (\n              <div key={table.key} className='table_method' >\n                <div className='full_cell'>\n                  <ValidatedInput\n                    placeholder={'Table Name'}\n                    isValid={(text) => validName(text, table)}\n                    onValid={(text) => tableChange({...table,\n                                                    name: text},\n                                                   table)}\n                    onEmpty={() => tableChange({...table,\n                                                name: yellow},\n                                               table)}\n                  />\n                  <RemButton\n                    onClick={() => remTable(table)}\n                    title='Remove this table'\n                  />\n                </div>\n                <SuccinctTab\n                  table={table}\n                  tableNames={props.tables.map((table) => table.name)}\n                  tableChange={(newTab) => tableChange(newTab, table)}\n                />\n              </div>\n          )),\n            <div key={peekKey()} className='table_method'>\n              <AddButton\n                onClick={addTable}\n              />\n            </div>]}\n        </div>\n    );\n}\n\nfunction SuccinctTab(props) {\n    function paramsExamplesChange(params, examples) {\n        props.tableChange({...props.table, params: params, examples: examples});\n    }\n\n    function formulasChange(formulas) {\n        props.tableChange({...props.table, formulas: formulas});\n    }\n\n    function examplesChange(examples) {\n        props.tableChange({...props.table, examples: examples});\n    }\n\n    return (\n        <table className={'html_table'}>\n          <SuccinctHead\n            params={props.table.params}\n            examples={props.table.examples}\n            tableNames={props.tableNames}\n            paramsExamplesChange={paramsExamplesChange}\n\n            formulas={props.table.formulas}\n            formulasChange={formulasChange}\n          />\n          <SuccinctBody\n            examples={props.table.examples}\n            formulas={props.table.formulas}\n            paramNames={props.table.params.map((param) => param.name)}\n            examplesChange={examplesChange}\n            formulasChange={formulasChange}\n          />\n        </table>\n    );\n}\n\nfunction SuccinctHead(props) {\n    // String -> Boolean\n    // checks if the given string is a valid program\n    function validProg(text) {\n        let isgood = true;\n\n        try {\n            parseCheck(text);\n        } catch(e) {\n            if (e instanceof SyntaxError) {\n                isgood = false;\n            } else { // this should never happen\n                throw e;\n            }\n        }\n\n        return isgood;\n    }\n\n    // Formula -> Side Effect\n    // removes a given formula from the tree\n    function remFormula(deadForm) {\n        const aliveForms = props.formulas.filter((formula) => formula !== deadForm);\n        props.formulasChange(aliveForms);\n    }\n\n    // Formula -> Formula -> Side Effect\n    // replaces one formula with another one\n    function formulaChange(newForm, oldForm) {\n\n        let alteredForms;\n        if (props.formulas.indexOf(oldForm) === -1) {\n            alteredForms = [...props.formulas, newForm];\n        } else {\n            alteredForms = props.formulas.map((form) => form === oldForm ? newForm : form);\n        }\n        props.formulasChange(alteredForms);\n    }\n\n    // Formula -> Number -> Number\n    // gives the maximum depth of a Formula, second parameter is an accumulator\n    function maxDepth(formula, curMax) {\n        if (!isBooleanFormula(formula)) {\n            return curMax;\n        } else {\n            return formula.thenChildren.reduce((acc, child) => Math.max(acc, maxDepth(child, curMax + 1)), curMax + 1);\n        }\n    }\n\n    function countWidth(formula) {\n        if (!isBooleanFormula(formula)) {\n            return 1;\n        } else {\n            return formula.thenChildren.reduce((acc, child) => acc + countWidth(child), 2);\n        }\n    }\n\n\n    // Number -> [Number]\n    // takes a number, returns an array that counts from 1 to that number, input of 0 gives empty array\n    // e.g. countUp(5) -> [1, 2, 3, 4, 5]\n    function countUp(num) {\n        // special case: want an empty array for 0\n        if (num === 0) {\n            return [];\n        } else if (num === 1)\n            return [1];\n        else\n            return [...countUp(num - 1), num];\n    }\n\n    const abyss = props.formulas.reduce((acc, formula) => Math.max(acc, maxDepth(formula, 0)), 0);\n    const numParams = props.params.length;\n\n    const reals = props.formulas.map((formula) => (\n        <th key={formula.key} colSpan={countWidth(formula)} >\n          <div className='full_cell'>\n            <ValidatedInput\n              placeholder={'Formula'}\n              dummy={false}\n              isValid={validProg}\n              onValid={(text) => formulaChange({...formula,\n                                                prog: parseCheck(text)},\n                                               formula)}\n              onEmpty={() => formulaChange({...formula,\n                                            prog: yellow},\n                                           formula)}\n            />\n            <RemButton\n              title={'Remove formula'}\n              onClick={() => remFormula(formula)}\n            />\n          </div>\n        </th>\n    ));\n\n    const dummy = (\n        <th key={peekKey()} colSpan={1}>\n          <div className='full_cell'>\n            <ValidatedInput\n              dummy={true}\n              placeholder='Add'\n              isValid={validProg}\n              onValid={(text) => formulaChange({prog: parseCheck(text),\n                                                outputs: props.examples.map((_) => yellow),\n                                                key: takeKey()},\n                                               {})}\n            />\n          </div>\n        </th>\n    );\n\n    const children = countUp(abyss).map((depth) => (\n        <tr key={depth}>\n          <th colSpan={numParams + 2}>{/* empty cell to align with example RemButton and Parameters */}</th>\n          {props.formulas.map((formula) => (\n              <DepictFormula\n                key={formula.key}\n                formula={formula}\n                depth={depth}\n                numExamples={props.examples.length}\n                formulaChange={(newForm) => formulaChange(newForm, formula)}\n              />\n          ))}\n        </tr>\n    ));\n\n    return (\n        <thead>\n          <tr>\n            <Parameters\n              params={props.params}\n              examples={props.examples}\n              tableNames={props.tableNames}\n              paramsExamplesChange={props.paramsExamplesChange}\n            />\n            {/* top level formulas */}\n            {[...reals, dummy]}\n          </tr>\n          {/* rest of formulas */}\n          {children}\n        </thead>\n    );\n}\n\nfunction Parameters(props) {\n    // \n    function validParam(text, modParam) {\n        function lookup(name, env) {\n            return env.reduce((acc, variable) => {\n                if (acc) {\n                    return true;\n                }\n\n                return variable.name === name;\n\n            }, false);\n        }\n\n        // These are not technically Variables, see note above\n        let paramVars = props.params.filter((param) => param !== modParam).map((param) => ({name: param.name, binding: null}));\n        let tableVars = props.tableNames.map((name) => ({name: name, binding: null}));\n        let env = [...initEnv, ...tableVars, ...paramVars];\n\n        const varRE = /^[a-zA-Z+\\-*/?=><]+$/; // change me\n\n        return varRE.test(text) && !lookup(text, env);\n    }\n\n    function remParam(deadParam) {\n        const deadIndex = props.params.indexOf(deadParam);\n        const aliveParams = props.params.filter((param) => param !== deadParam);\n\n        // need to maintain #inputs = #params\n        const modExamples = props.examples.map((example => ({...example,\n                                                             inputs: example.inputs.filter((_, i) => i !== deadIndex)})));\n\n        props.paramsExamplesChange(aliveParams, modExamples);\n    }\n\n    // String -> Number -> Side Effect\n    // changes the name of the given parameter\n    // if that parameter doesn't exist yet, it makes it\n    function paramChange(newParam, modParam) {\n\n        let alteredParams, alteredExamples;\n        if (props.params.indexOf(modParam) === -1) {\n            alteredParams = [...props.params, newParam];\n            // need to maintain #inputs = #params\n            alteredExamples = props.examples.map((example) => ({...example,\n                                                                inputs: [...example.inputs, {prog: yellow, key: takeKey()}]}));\n        } else {\n            alteredParams = props.params.map((param) => param === modParam ? newParam : param);\n            // examples don't actually change\n            alteredExamples = props.examples;\n        }\n\n        props.paramsExamplesChange(alteredParams, alteredExamples);\n    }\n\n    const reals = props.params.map((param) => (\n        <th key={param.key} >\n          <div className='full_cell'>\n            <ValidatedInput\n              dummy={false}\n              placeholder='Parameter'\n              isValid={(text) => validParam(text, param)}\n              onValid={(text) => paramChange({...param,\n                                              name: text},\n                                             param)}\n              onEmpty={() => paramChange({...param,\n                                          name: yellow},\n                                         param)}\n            />\n            <RemButton\n              title='remove this parameter'\n              onClick={() => remParam(param)}\n            />\n          </div>\n        </th>\n    ));\n\n    const dummy = (\n        <th key={peekKey()}>\n          <div className='full_cell'>\n            <ValidatedInput\n              dummy={true}\n              placeholder='Add'\n              isValid={(text) => validParam(text, {})}\n              onValid={(text) => paramChange({name: text,\n                                              key: takeKey()},\n                                             {})}\n            />\n          </div>\n        </th>\n    );\n\n    return (\n        <React.Fragment>\n          <th>{/* empty cell to align with example RemButtons */}</th>\n          <React.Fragment>\n            {[...reals, dummy]}\n          </React.Fragment>\n        </React.Fragment>\n    );\n}\n\n/*\n  props: formula, depth, kill, formulaChange\n*/\nfunction DepictFormula(props) {\n    function validProg(text) {\n        let isgood = true;\n\n        try {\n            parseCheck(text);\n        } catch(e) {\n            if (e instanceof SyntaxError) {\n                isgood = false;\n            } else {\n                throw e;\n            }\n        }\n\n        return isgood;\n    }\n\n    // this is pretty macabre...\n    function remChild(deadChild) {\n        const aliveChildren = props.formula.thenChildren.filter((child) => child !== deadChild);\n        props.formulaChange({...props.formula, thenChildren: aliveChildren});\n    }\n\n    function childChange(newChild, modChild) {\n        let children;\n        if (props.formula.thenChildren.indexOf(modChild) === -1) {\n            children = [...props.formula.thenChildren, newChild];\n        } else {\n            children = props.formula.thenChildren.map((child) => child === modChild ? newChild : child);\n        }\n        props.formulaChange({...props.formula, thenChildren: children});\n    }\n\n    function countWidth(formula) {\n        if (!isBooleanFormula(formula)) {\n            return 1;\n        } else {\n            return formula.thenChildren.reduce((acc, child) => acc + countWidth(child), 2);\n        }\n    }\n\n    if (props.depth > 1) {\n        return (\n            <React.Fragment>\n              <th>{/* empty cell to align with parent input */}</th>\n              {isBooleanFormula(props.formula) ?\n               <React.Fragment>\n                 {props.formula.thenChildren.map((child) => (\n                     <DepictFormula\n                       key={child.key}\n                       formula={child}\n                       depth={props.depth - 1}\n                       numExamples={props.numExamples}\n                       formulaChange={(formula) => childChange(formula, child)}\n                     />))}\n                 <th>{/* empty cell to align with child input */}</th>\n               </React.Fragment>\n               : <script/> }\n            </React.Fragment>\n        );\n    } else {\n        const reals = props.formula.thenChildren.map((child) => (\n            <th key={child.key} colSpan={countWidth(child)} >\n              <div className='full_cell'>\n                <ValidatedInput\n                  dummy={false}\n                  placeholder={'Formula'}\n                  isValid={validProg}\n                  onValid={(text) => childChange({...child,\n                                                  prog: parseCheck(text)},\n                                                 child)}\n                  onEmpty={() => childChange({...child,\n                                              prog: yellow},\n                                             child)}\n                />\n                <RemButton\n                  title={'Remove formula'}\n                  onClick={() => remChild(child)}\n                />\n              </div>\n            </th>\n        ));\n\n        const dummy = (\n            <th key={peekKey()} colSpan={1}>\n              <div className='full_cell'>\n                <ValidatedInput\n                  dummy={true}\n                  placeholder='Add'\n                  isValid={validProg}\n                  onValid={(text) => childChange({prog: parseCheck(text),\n                                                  outputs: Array(props.numExamples).fill(yellow),\n                                                  key: takeKey()},\n                                                 {})}\n                />\n              </div>\n            </th>\n        );\n\n        return (\n            <React.Fragment>\n              <th>{/* empty cell to align with parent input */}</th>\n              {isBooleanFormula(props.formula) ?\n               <React.Fragment>\n                 {[...reals, dummy]}\n               </React.Fragment>\n               : <script/> }\n            </React.Fragment>\n        );\n    }\n}\n\nfunction SuccinctBody(props) {\n    function remExample(deadExample) {\n        const aliveExamples = props.examples.filter((example) => example !== deadExample);\n        props.examplesChange(aliveExamples);\n    }\n\n    function exampleChange(newExample, oldExample) {\n        const exists = props.examples.indexOf(oldExample) !== -1;\n\n        if (newExample === dryRun) {\n            return exists;\n        }\n\n        let alteredExamples;\n        if (exists) {\n            alteredExamples = props.examples.map((example) => example === oldExample ? newExample : example);\n        } else {\n            alteredExamples = [...props.examples, newExample];\n        }\n        props.examplesChange(alteredExamples);\n        return true; // this doesn't actually do anything\n    }\n\n    const reals = props.examples.map((example, i) => (\n          <tr key={example.key}>\n            <td>\n              <RemButton\n                onClick={() => remExample(example)}\n                title={'Remove this example'}\n              />\n            </td>\n            <Inputs\n              dummy={false}\n              inputs={example.inputs}\n              inputsChange={(inputs) => exampleChange({...example, inputs},\n                                                      example)}\n            />\n            <td>{/* empty cell to align with param AddButton */}</td>\n            <Outputs\n              dummy={false}\n              formulas={props.formulas}\n              want={example.want}\n              row={i}\n            />\n            <td>{/* empty cell to align with top level formula AddButton */}</td>\n            <Want\n              dummy={false}\n              wantChange={(want) => exampleChange({...example, want},\n                                                  example)}\n            />\n          </tr>\n    ));\n    \n    const dummy = (\n          <tr key={peekKey(props.paramNames.length)}>\n            <td>{/* empty cell to offset rembutton */}</td>\n            <Inputs\n              dummy={true}\n              inputs={props.paramNames.map((_, i) => ({key: peekKey(i)}))}\n              inputsChange={(inputs) => exampleChange({inputs,\n                                                       want: yellow,\n                                                       key: takeKey()},\n                                                      {})}\n            />\n            <td>{/* empty cell to align with param AddButton */}</td>\n            <Outputs\n              dummy={true}\n              formulas={props.formulas}\n            />\n            <td>{/* empty cell to align with top level formula AddButton */}</td>\n            <Want\n              dummy={true}\n              wantChange={(want) => exampleChange({want,\n                                                   inputs: props.paramNames.map((_) => ({prog: yellow, key: takeKey()})),\n                                                   key: takeKey()},\n                                                  {})}\n            />\n          </tr>\n    );\n\n    return (\n        <tbody>\n          {[...reals, dummy]}\n        </tbody>\n    );\n}\n\nfunction Inputs(props) {\n    function validProg(text) {\n        let goodText = true;\n\n        try {\n            parseCheck(text);\n        } catch(e) {\n            if (e instanceof SyntaxError) {\n                goodText = false;\n            } else {\n                throw e;\n            }\n        }\n\n        return goodText;\n    }\n\n    function inputChange(newInput, oldInput) {\n        let alteredInputs;\n        if (props.dummy) {\n            alteredInputs = props.inputs.map((input) => input === oldInput ? {...newInput, key: takeKey()} : {prog: yellow, key: takeKey()});\n        } else {\n            alteredInputs = props.inputs.map((input) => input === oldInput ? newInput : input);\n        }\n        props.inputsChange(alteredInputs);\n    }\n\n    return (\n        <React.Fragment>\n          {props.inputs.map((input, i) => (\n              <td key={input.key} >\n                <ValidatedInput\n                  dummy={props.dummy}\n                  placeholder={'Input'}\n                  isValid={validProg}\n                  onValid={props.dummy ?\n                           (text) => inputChange({prog: parseCheck(text)},\n                                                  input)\n                           :\n                           (text) => inputChange({...input,\n                                                  prog: parseCheck(text)},\n                                                 input)}\n                  \n                  onEmpty={() => inputChange({...input,\n                                              prog: yellow},\n                                             input)}\n                />\n              </td>\n          ))}\n        </React.Fragment>\n    );\n}\n\nfunction Outputs(props) {\n    function countWidth(formula) {\n        if (!isBooleanFormula(formula)) {\n            return 1;\n        } else {\n            return formula.thenChildren.reduce((acc, child) => acc + countWidth(child), 2);\n        }\n    }\n\n    if (props.dummy) {\n        return (\n            <React.Fragment>\n            {props.formulas.map((formula) => (\n                <td key={formula.key} colSpan={countWidth(formula)}>{/* empty cell */}</td>\n            ))}\n            </React.Fragment>\n        );\n    } else {\n        return (\n            <React.Fragment>\n              {props.formulas.map((formula) => (\n                  <React.Fragment key={formula.key}>\n                    <TestCell\n                      output={formula.outputs[props.row]}\n                      want={props.want}\n                    />\n                    {isBooleanFormula(formula) ?\n                     <React.Fragment>\n                       <Outputs\n                         formulas={formula.thenChildren}\n                         want={props.want}\n                         row={props.row}\n                       />\n                       <td>{/* empty cell to align with dummy child */}</td>\n                     </React.Fragment>\n                     : <script/> }\n                  </React.Fragment>\n              ))}\n            </React.Fragment>\n        );\n    }\n}\n\nfunction TestCell(props) {\n\n    if (props.output === gray) {\n        return (\n            <td className={'gray'}>\n            </td>\n        );\n    }\n\n    if (props.output === pink) {\n        return (\n            <td className={'pink'}>\n            </td>\n        );\n    }\n\n    if (props.output === yellow) {\n        return (\n            <td className={'yellow'}>\n            </td>\n        );\n    }\n\n    let output = props.output;\n    let want = yellow;\n\n    if (props.want !== yellow) {\n        try {\n            want = interp(props.want, initEnv);\n        } catch (e) {\n            output = e;\n        }\n    }\n\n    let text, error;\n    if (output instanceof Error) {\n        text = output.message;\n        error = true;\n    } else {\n        text = unParse(output);\n        error = false;\n    }\n\n    let img;\n    if (error) {\n        img = <img\n                src={imgPath + 'frowneyface.png'}\n                alt='Error!'\n                style={{float: 'right'}}\n                title={\"Oh no! You got an error!\"}/>;\n    }else if (want === yellow) { // I should make this better\n        img = '';\n    } else if (deepEquals(output, want)) {\n        img =  <img\n                 src={imgPath + 'smileyface.png'}\n                 alt='Yay!'\n                 style={{float: 'right'}}\n                 title={\"Yay! It's right!\"}/>;\n    } else {\n        img = '';\n    }\n\n    return (\n        <td className={'output'}>\n          {text}\n          {img}\n        </td>\n    );\n}\n\nfunction Want(props) {\n    function validProg(text) {\n        let goodText = true;\n\n        try {\n            parseCheck(text);\n        } catch(e) {\n            if (e instanceof SyntaxError) {\n                goodText = false;\n            } else {\n                throw e;\n            }\n        }\n\n        return goodText;\n    }\n\n    return (\n        <td>\n          <ValidatedInput\n            dummy={props.dummy}\n            placeholder={'Want'}\n            isValid={validProg}\n            onValid={(text) => props.wantChange(parseCheck(text))}\n            onEmpty={() => props.wantChange(yellow)}\n          />\n        </td>\n    );\n}\n\n/*\n  notes:\n  #inputs === #params\n  #outputs === #examples\n  ---------------------\n  |#inputs !== #outputs| (well it can but not always)\n  ---------------------\n*/\n\nclass App extends React.Component {\n    constructor(props){\n        super(props);\n        let tables = [{examples: [{inputs: [{prog: yellow, key: takeKey()}], want: yellow, key: takeKey()}],\n                       formulas: [{prog: yellow, outputs: [yellow], key: takeKey()}],\n                       params: [{name: yellow, key: takeKey()}],\n                       name: yellow,\n                       key: takeKey()}];\n        this.state = {tables};\n\n        this.programChange = this.programChange.bind(this);\n    }\n\n    calculate(program) {\n        function makeLookup(table) {\n            function lookup(args, env) {\n                if (args.length !== table.params.length) {\n                    throw new Error('Arity Mismatch, expected ' + table.params.length + ' argument' + (table.params.length === 1 ? '' : 's'));\n                }\n\n                let interpArgs = args.map((arg) => interp(arg, env));\n\n                let expr = table.examples.reduce((acc, example) => {\n                    if (acc !== undefined) {\n                        return acc;\n                    }\n\n                    // I have no idea what should happen if this is called on a table with no params\n                    if (example.inputs.reduce((acc, input, i) => {\n                        // like my pun?\n                        let INterped = interp(input.prog, env);\n                        return acc && deepEquals(INterped, interpArgs[i]);\n\n                    }, true)) {\n                        return interp(example.want, env);\n                    }\n\n                    return undefined;\n                }, undefined);\n\n                if (expr === undefined) {\n                    // it's like a reference error in the super meta table language\n                    throw new ReferenceError(interpArgs.map(unParse).join() + ' is not an example in ' + table.name);\n                }\n\n                return expr;\n            }\n\n            return lookup;\n        }\n\n        let lookups = program.map((table) => ({name: table.name, binding: {value: makeLookup(table), type: RFUNCT_T}}));\n        let globalEnv = [...initEnv, ...lookups];\n\n        function calcTable(table) {\n            function calcFormula(formula, examples) {\n                let outputs = examples.map((example) => {\n                    if (example === gray) {\n                        return gray;\n                    } else if (example === pink) {\n                        return pink;\n                    } else if (!example.inputs.every((input) => input.prog !== yellow) || formula.prog === yellow) { // if any inputs or the formula aren't initialized\n                        return yellow;\n                    }\n\n                    let localEnv = table.params.map((param, i) => ({name: param.name, binding: example.inputs[i].prog}));\n                    let env = [...globalEnv, ...localEnv];\n\n                    try {\n                        var output = interp(formula.prog, env);\n                    } catch (e) {\n                        output = e;\n                    }\n\n                    return output;\n                });\n\n                if (allBools(outputs) || (formula.thenChildren !== undefined && formula.thenChildren.length !== 0)) {\n                    function maybeSpecial(example, output) {\n                        if (example === gray || output.value === false)\n                            return gray;\n                        else if (typeof output.value !== 'boolean')\n                            return pink;\n                        else\n                            return example;\n                    }\n\n                    if (formula.thenChildren === undefined) {\n                        var thenChildren = [];\n                    } else {\n                        let subExamples = examples.map((example, i) => maybeSpecial(example, outputs[i]));\n                        thenChildren = formula.thenChildren.map((formula) => calcFormula(formula, subExamples));\n                    }\n\n                    return {...formula,\n                            outputs,\n                            thenChildren};\n                } else {\n                    let newFormula = {...formula,\n                                      outputs};\n                    delete newFormula.thenChildren;\n                    return newFormula;\n                }\n            }\n\n            if (table.name === yellow || !table.params.every((param) => param.name !== yellow)) { // if the table or any of the table's parameters don't have a name yet, don't calculate\n                // I should probably change this at some point, as it is it pretty much overwrites all outputs if a new parameter is added, although I guess it would do that anyway because of how init inputs are treated\n                let formulas = table.formulas.map((formula) => ({...formula, outputs: Array(table.examples.length).fill(yellow)}));\n                return {...table,\n                        formulas};\n            } else {\n                let formulas = table.formulas.map((formula) => calcFormula(formula, table.examples));\n                return {...table,\n                        formulas};\n            }\n\n        }\n\n        return program.map(calcTable);\n    }\n\n    programChange(newProg) {\n        let calkedProg = this.calculate(newProg);\n        console.log(calkedProg);\n        //console.log('next key: ', peekKey());\n        //console.log(toBSL(calkedProg));\n        this.setState((state) => {\n            return {tables: calkedProg};\n        });\n    }\n\n    render(){\n        return (\n            <div>\n              <Succinct\n                tables={this.state.tables}\n                programChange={this.programChange}\n              />\n              <textarea\n                rows={10}\n                cols={50}\n                className='bsl_io'\n                readOnly={true}\n                value={toBSL(this.state.tables)}\n              />\n            </div>\n        );\n    }\n}\n\nexport default App;\n","// This optional code is used to register a service worker.\n// register() is not called by default.\n\n// This lets the app load faster on subsequent visits in production, and gives\n// it offline capabilities. However, it also means that developers (and users)\n// will only see deployed updates on subsequent visits to a page, after all the\n// existing tabs open on the page have been closed, since previously cached\n// resources are updated in the background.\n\n// To learn more about the benefits of this model and instructions on how to\n// opt-in, read https://bit.ly/CRA-PWA\n\nconst isLocalhost = Boolean(\n  window.location.hostname === 'localhost' ||\n    // [::1] is the IPv6 localhost address.\n    window.location.hostname === '[::1]' ||\n    // 127.0.0.1/8 is considered localhost for IPv4.\n    window.location.hostname.match(\n      /^127(?:\\.(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)){3}$/\n    )\n);\n\nexport function register(config) {\n  if (process.env.NODE_ENV === 'production' && 'serviceWorker' in navigator) {\n    // The URL constructor is available in all browsers that support SW.\n    const publicUrl = new URL(process.env.PUBLIC_URL, window.location.href);\n    if (publicUrl.origin !== window.location.origin) {\n      // Our service worker won't work if PUBLIC_URL is on a different origin\n      // from what our page is served on. This might happen if a CDN is used to\n      // serve assets; see https://github.com/facebook/create-react-app/issues/2374\n      return;\n    }\n\n    window.addEventListener('load', () => {\n      const swUrl = `${process.env.PUBLIC_URL}/service-worker.js`;\n\n      if (isLocalhost) {\n        // This is running on localhost. Let's check if a service worker still exists or not.\n        checkValidServiceWorker(swUrl, config);\n\n        // Add some additional logging to localhost, pointing developers to the\n        // service worker/PWA documentation.\n        navigator.serviceWorker.ready.then(() => {\n          console.log(\n            'This web app is being served cache-first by a service ' +\n              'worker. To learn more, visit https://bit.ly/CRA-PWA'\n          );\n        });\n      } else {\n        // Is not localhost. Just register service worker\n        registerValidSW(swUrl, config);\n      }\n    });\n  }\n}\n\nfunction registerValidSW(swUrl, config) {\n  navigator.serviceWorker\n    .register(swUrl)\n    .then(registration => {\n      registration.onupdatefound = () => {\n        const installingWorker = registration.installing;\n        if (installingWorker == null) {\n          return;\n        }\n        installingWorker.onstatechange = () => {\n          if (installingWorker.state === 'installed') {\n            if (navigator.serviceWorker.controller) {\n              // At this point, the updated precached content has been fetched,\n              // but the previous service worker will still serve the older\n              // content until all client tabs are closed.\n              console.log(\n                'New content is available and will be used when all ' +\n                  'tabs for this page are closed. See https://bit.ly/CRA-PWA.'\n              );\n\n              // Execute callback\n              if (config && config.onUpdate) {\n                config.onUpdate(registration);\n              }\n            } else {\n              // At this point, everything has been precached.\n              // It's the perfect time to display a\n              // \"Content is cached for offline use.\" message.\n              console.log('Content is cached for offline use.');\n\n              // Execute callback\n              if (config && config.onSuccess) {\n                config.onSuccess(registration);\n              }\n            }\n          }\n        };\n      };\n    })\n    .catch(error => {\n      console.error('Error during service worker registration:', error);\n    });\n}\n\nfunction checkValidServiceWorker(swUrl, config) {\n  // Check if the service worker can be found. If it can't reload the page.\n  fetch(swUrl)\n    .then(response => {\n      // Ensure service worker exists, and that we really are getting a JS file.\n      const contentType = response.headers.get('content-type');\n      if (\n        response.status === 404 ||\n        (contentType != null && contentType.indexOf('javascript') === -1)\n      ) {\n        // No service worker found. Probably a different app. Reload the page.\n        navigator.serviceWorker.ready.then(registration => {\n          registration.unregister().then(() => {\n            window.location.reload();\n          });\n        });\n      } else {\n        // Service worker found. Proceed as normal.\n        registerValidSW(swUrl, config);\n      }\n    })\n    .catch(() => {\n      console.log(\n        'No internet connection found. App is running in offline mode.'\n      );\n    });\n}\n\nexport function unregister() {\n  if ('serviceWorker' in navigator) {\n    navigator.serviceWorker.ready.then(registration => {\n      registration.unregister();\n    });\n  }\n}\n","import React from 'react';\nimport ReactDOM from 'react-dom';\nimport './index.css';\nimport App from './App';\nimport * as serviceWorker from './serviceWorker';\n\nReactDOM.render(<App />, document.getElementById('root'));\n\n// If you want your app to work offline and load faster, you can change\n// unregister() to register() below. Note this comes with some pitfalls.\n// Learn more about service workers: https://bit.ly/CRA-PWA\nserviceWorker.unregister();\n"],"sourceRoot":""}