{"version":3,"sources":["interpreter.js","header.js","prettyprint.js","App.js","serviceWorker.js","index.js"],"names":["RVAR_T","RAPP_T","RFUNCT_T","RNUM_T","RBOOL_T","RSTRING_T","RLIST_T","RSYM_T","varRE","appRE","numRE","boolRE","strRE","quoteRE","symRE","listRE","initEnv","name","binding","type","value","args","forEach","cur","typeCheck","reduce","acc","length","firstArg","secondArg","car","cdr","Error","a","d","reverse","arg","thirdArg","isnull","val","parse","text","test","numStr","match","rest","slice","trim","prog","boolStr","toLowerCase","matches","parseFunct","funct","parseArg","concat","Object","toConsumableArray","parseQ","listArr","num","bool","charAt","str","sym","SyntaxError","interp","env","variable","undefined","ReferenceError","lookup","map","TypeError","unparse_cons","join","unparse_list","elems","parseCheck","parsed","typeString","gray","pink","yellow","allBools","progs","every","isBooleanFormula","formula","outputs","thenChildren","nil","string","String","line","union","docL","docR","left","right","compose","nest","i","doc","indent","group","flatten","makePretty","width","ribbon","best","thisRibbon","current","fits","deltaWidth","deltaRibbon","better","layout","repeat","putSpace","putLine","folddoc","f","docs","splice","spread","stack","level","toBSL","program","unparse","pretty","table","inputToDoc","params","param","checkExpects","examples","example","inputs","input","want","body","formulas","formulaToDoc","children","dryRun","yo","imgPath","keyCount","takeKey","peekKey","lookahead","showBSL","deepEquals","proga","progb","functCheck","argCheck","arga","elem","RemButton","props","react_default","createElement","className","style","src","alt","title","onClick","ValidatedInput","_this","classCallCheck","this","possibleConstructorReturn","getPrototypeOf","call","state","textChange","bind","assertThisInitialized","e","target","setState","isValid","onValid","dummy","onEmpty","size","placeholder","Math","max","onChange","React","Component","Succinct","tableChange","newTab","oldTab","alteredTabs","tables","indexOf","programChange","validName","modTab","tableVars","filter","otherTab","paramVars","reals","key","App_ValidatedInput","objectSpread","deadTab","aliveTabs","remTable","SuccinctTab","tableNames","formulasChange","SuccinctHead","paramsExamplesChange","SuccinctBody","paramNames","examplesFormulasChange","validProg","isgood","formulaChange","newForm","oldForm","alteredForms","form","countWidth","child","abyss","maxDepth","curMax","numParams","colSpan","deadForm","aliveForms","remFormula","_","countUp","depth","DepictFormula","numExamples","Parameters","validParam","modParam","paramChange","newParam","alteredParams","alteredExamples","deadParam","deadIndex","aliveParams","modExamples","remParam","Fragment","childChange","newChild","modChild","deadChild","aliveChildren","remChild","Array","fill","exampleChange","newExample","oldExample","exists","addAnotherOutputToFormula","deadExample","aliveExamples","removeOutputFromFormula","remExample","Inputs","inputsChange","Outputs","row","Want","wantChange","inputChange","newInput","oldInput","alteredInputs","TestCell","output","error","img","message","float","App","_this2","makeLookup","expr","lookups","globalEnv","calcFormula","localEnv","subExamples","maybeSpecial","newFormula","newProg","calkedProg","calculate","bslField","_this3","rows","cols","readOnly","id","htmlFor","defaultValue","Boolean","window","location","hostname","ReactDOM","render","src_App_0","document","getElementById","navigator","serviceWorker","ready","then","registration","unregister"],"mappings":"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","file":"static/js/main.09aca52d.chunk.js","sourcesContent":["\n/****************\n   Interpreter\n****************/\n\nconst RVAR_T =    0;\nconst RAPP_T =    1;\nconst RFUNCT_T =   2;\nconst RNUM_T =    3;\nconst RBOOL_T =   4;\nconst RSTRING_T = 5;\nconst RLIST_T =   6;\nconst RSYM_T =    7;\n\nconst varRE = /^[^\\s\",'`()[\\]{}|;#]+/; // except numbers\nconst appRE = /^\\(/;\nconst numRE = /^-?(?:\\d+(?:\\.\\d*)?|\\.\\d+)(?=$|[\\s\",'`()[\\]{}|;#])/; // this one doesn't permit fractions\nconst boolRE = /^#(?:[tfTF]|true|false)(?=$|[\\s\",'`()[\\]{}|;#])/;\nconst strRE = /^\"[^\\\\\"]*\"/; // TODO: handle backslash escape\nconst quoteRE = /^'/;\nconst symRE = /^[^\\s\",'`()[\\]{}|;#]+/; // except numbers\nconst listRE = /^\\(/;\n\nconst initEnv = [\n    // functions\n    {name: '+', binding: {type: RFUNCT_T,\n                          value: plus}},\n    {name: '-', binding: {type: RFUNCT_T,\n                          value: minus}},\n    {name: '*', binding: {type: RFUNCT_T,\n                          value: times}},\n    {name: '/', binding: {type: RFUNCT_T,\n                          value: divide}},\n    {name: 'car', binding: {type: RFUNCT_T,\n                            value: car}},\n    {name: 'first', binding: {type: RFUNCT_T,\n                              value: car}},\n    {name: 'cdr', binding: {type: RFUNCT_T,\n                            value: cdr}},\n    {name: 'rest', binding: {type: RFUNCT_T,\n                             value: cdr}},\n    {name: 'cons', binding: {type: RFUNCT_T,\n                             value: cons}},\n    {name: 'list', binding: {type: RFUNCT_T,\n                             value: list}},\n    {name: 'not', binding: {type: RFUNCT_T,\n                            value: not}},\n    {name: 'and', binding: {type: RFUNCT_T,\n                            value: and}},\n    {name: 'or', binding: {type: RFUNCT_T,\n                           value: or}},\n    {name: 'if', binding: {type: RFUNCT_T,\n                           value: rif}},\n    {name: 'eqv?', binding: {type: RFUNCT_T,\n                             value: iseqv}},\n    {name: 'null?', binding: {type: RFUNCT_T,\n                              value: isnull}},\n    {name: 'empty?', binding: {type: RFUNCT_T,\n                               value: isnull}},\n    {name: 'cons?', binding: {type: RFUNCT_T,\n                               value: iscons}},\n    {name: '=', binding: {type: RFUNCT_T,\n                          value: equalsign}},\n    {name: '>', binding: {type: RFUNCT_T,\n                          value: gtsign}},\n    {name: '>=', binding: {type: RFUNCT_T,\n                           value: gesign}},\n    {name: '<', binding: {type: RFUNCT_T,\n                          value: ltsign}},\n    {name: '<=', binding: {type: RFUNCT_T,\n                           value: lesign}},\n    // constants\n    {name: 'true', binding: {type: RBOOL_T,\n                             value: true}},\n    {name: 'false', binding: {type: RBOOL_T,\n                              value: false}},\n    {name: 'null', binding: {type: RLIST_T,\n                             value: null}},\n    {name: 'empty', binding: {type: RLIST_T,\n                              value: null}},\n];\n\n// String -> {prog: Program, rest: String}\n// parses all expressions except quoted expressions\nfunction parse(text) {\n    if (numRE.test(text)) {\n        let matches = text.match(numRE);\n        let numStr = matches[0];\n        let rest = text.slice(numStr.length).trim();\n        let num = {value: +numStr, type: RNUM_T};\n\n        return {prog: num, rest: rest};\n    } else if (varRE.test(text)) {\n        let matches = text.match(varRE);\n        let name = matches[0];\n        let rest = text.slice(name.length).trim();\n        let variable = {value: name, type: RVAR_T};\n\n        return {prog: variable, rest: rest};\n\n\n    } else if (boolRE.test(text)) {\n        let matches = text.match(boolRE);\n        let boolStr = matches[0];\n        let rest = text.slice(boolStr.length).trim();\n        let bool = {value: boolStr[1].toLowerCase() === 't', type: RBOOL_T};\n\n        return {prog: bool, rest: rest};\n\n    } else if (strRE.test(text)) {\n        let matches = text.match(strRE);\n        let str = {value: matches[0], type: RSTRING_T};\n        let rest = text.slice(matches[0].length).trim();\n\n        return {prog: str, rest: rest};\n\n    } else if (appRE.test(text)) {\n        text = text.slice(1).trim(); // remove open paren\n        let parseFunct = parse(text); // parse function\n        let funct = parseFunct.prog; // get function\n        text = parseFunct.rest; // get past function\n        let args = [];\n\n        while (text[0] !== ')') {\n            let parseArg = parse(text);\n            args = [...args, parseArg.prog];\n            text = parseArg.rest;\n        }\n\n        let app = {value: {funct: funct, args: args}, type: RAPP_T};\n        let rest = text.slice(1).trim(); // remove close paren\n\n        return {prog: app, rest: rest};\n\n    } else if (quoteRE.test(text)) {\n        return parseQ(text.slice(1).trim());\n    }\n\n    throw new SyntaxError('Invalid Syntax: \"' + text + '\"');\n}\n\n// String -> {prog: Program, rest: String}\n// parses quoted expressions\nfunction parseQ(text) {\n    if (listRE.test(text)) {\n        text = text.slice(1).trim(); // remove quote, open paren\n        let listArr = [];\n\n        while (text[0] !== ')') {\n            let cur = parseQ(text);\n            listArr = [cur.prog, ...listArr]; // listArr is constructed backwards\n            text = cur.rest;\n        }\n\n        let rest = text.slice(1).trim();\n        let prog = listArr.reduce((acc, cur) => ({value: {a: cur, d: acc}, type: RLIST_T}), {value: null, type: RLIST_T}); // turn listArr into an Rlist\n\n        return {prog: prog, rest: rest};\n\n    } else if (numRE.test(text)) {\n        let matches = text.match(numRE);\n        let numStr = matches[0];\n        let rest = text.slice(numStr.length).trim();\n        let num = {value: +numStr, type: RNUM_T};\n\n        return {prog: num, rest: rest};\n\n    } else if (boolRE.test(text)) {\n        let matches = text.match(boolRE);\n        let boolStr = matches[0];\n        let rest = text.slice(boolStr.length).trim();\n        let bool = {value: boolStr.charAt(1).toLowerCase() === 't', type: RBOOL_T};\n\n        return {prog: bool, rest: rest};\n\n    } else if (strRE.test(text)) {\n        let matches = text.match(strRE);\n        let str = {value: matches[0], type: RSTRING_T};\n        let rest = text.slice(matches[0].length).trim();\n\n        return {prog: str, rest: rest};\n\n    } else if (symRE.test(text)) {\n        let matches = text.match(symRE);\n        let value = matches[0];\n        let sym = {value: '\\'' + value, type: RSYM_T}; // TODO value should not be stored with apostrophe\n        let rest = text.slice(matches[0].length).trim();\n\n        return {prog: sym, rest: rest};\n    }\n\n    throw new SyntaxError('Invalid Syntax: \"' + text + '\"');\n}\n\n/***\n    Environment: [Variable]\n    Variable:    {name:    String,\n    binding: Program}\n***/\n\n// Program -> Environment -> Program\nfunction interp(prog, env) {\n    function lookup(name) {\n        let val = env.reduce((acc, variable) => {\n            if (acc !== undefined) {\n                return acc;\n            }\n\n            return variable.name === name ? variable.binding : undefined;\n        }, undefined);\n\n        if (val === undefined){\n            throw new ReferenceError(name + ' isn\\'t defined');\n        }\n\n        return val;\n    }\n\n    switch(prog.type) {\n    case RNUM_T:\n        return prog;\n    case RBOOL_T:\n        return prog;\n    case RSTRING_T:\n        return prog;\n    case RLIST_T:\n        return prog;\n    case RSYM_T:\n        return prog;\n    case RVAR_T:\n        return lookup(prog.value);\n    case RFUNCT_T:\n        return prog;\n    case RAPP_T:\n        // interpret function (valof rator env)\n        let funct = interp(prog.value.funct, env);\n        // interpret arguments (valof rand env)\n        let args = prog.value.args.map((arg) => interp(arg, env));\n\n        typeCheck(funct, RFUNCT_T);\n\n        return funct.value(args);\n\n    default:\n        throw new TypeError(\"Unknown Type \" + prog.value);\n    }\n}\n\n// Program -> String\nfunction unparse_cons(prog) {\n    switch (prog.type) {\n    case RNUM_T:\n        return prog.value;\n    case RBOOL_T:\n        return '#' + (prog.value ? 'true' : 'false');\n    case RSTRING_T:\n        return prog.value;\n    case RLIST_T:\n        if (prog.value === null) {\n            return '\\'()';\n        } else {\n            return `(cons ${unparse_cons(prog.value.a)} ${unparse_cons(prog.value.d)})`;\n        }\n    case RSYM_T:\n        return prog.value;\n    case RVAR_T:\n        return prog.value;\n    case RFUNCT_T:\n        return 'function';\n    case RAPP_T:\n        return `(${unparse_cons(prog.value.funct)} ${prog.value.args.map(unparse_cons).join(' ')})`;\n    default:\n        return 'error or something';\n    }\n}\n\n// Program -> String\nfunction unparse_list (prog) {\n    switch (prog.type) {\n    case RNUM_T:\n        return prog.value;\n    case RBOOL_T:\n        return '#' + (prog.value ? 'true' : 'false');\n    case RSTRING_T:\n        return prog.value;\n    case RLIST_T:\n        let elems = '';\n        while (prog.value !== null) {\n            elems += ' ' + unparse_list(prog.value.a);\n            prog = prog.value.d;\n        }\n        return `(list${elems})`;\n    case RSYM_T:\n        return prog.value;\n    case RVAR_T:\n        return prog.value;\n    case RFUNCT_T:\n        return 'function';\n    case RAPP_T:\n        return `(${unparse_list(prog.value.funct)} ${prog.value.args.map(unparse_list).join(' ')})`;\n    default:\n        return 'error or something';\n    }\n}\n\n// String -> Program\n// parses text and checks for syntax errors based on what's returned\nfunction parseCheck(text) {\n    let parsed = parse(text);\n\n    switch (parsed.rest) {\n    case '':\n        break;\n    default:\n        throw new SyntaxError('Parsing Error');\n    }\n\n    return parsed.prog;\n}\n\n// Program -> Number -> Side Effect Maybe\nfunction typeCheck(prog, type){\n    let typeString = '';\n    switch (type) {\n    case RVAR_T:\n        typeString = 'variable';\n        break;\n    case RAPP_T:\n        typeString = 'application';\n        break;\n    case RFUNCT_T:\n        typeString = 'function';\n        break;\n    case RNUM_T:\n        typeString = 'number';\n        break;\n    case RBOOL_T:\n        typeString = 'boolean';\n        break;\n    case RSTRING_T:\n        typeString = 'string';\n        break;\n    case RLIST_T:\n        typeString = 'list';\n        break;\n    case RSYM_T:\n        typeString = 'symbol';\n        break;\n    default:\n        typeString = '???';\n    }\n\n    if (prog.type !== type){\n        // TODO maybe change me to use whatever unpareser is currently being used somehow\n        throw new TypeError(unparse_cons(prog) + ' ain\\'t a ' + typeString);\n    }\n}\n\nfunction plus(args) {\n    args.forEach((cur) => typeCheck(cur, RNUM_T));\n\n    return args.reduce((acc, cur) => {\n        return {value: acc.value + cur.value,\n                type: RNUM_T};\n    });\n}\nfunction minus(args) {\n    args.forEach((cur) => typeCheck(cur, RNUM_T));\n\n    return args.reduce((acc, cur) => {\n        return {value: acc.value - cur.value,\n                type: RNUM_T};\n    });\n}\nfunction times(args) {\n    args.forEach((cur) => typeCheck(cur, RNUM_T));\n\n    return args.reduce((acc, cur) => {\n        return {value: acc.value * cur.value,\n                type: RNUM_T};\n    });\n}\nfunction divide(args) {\n    if (args.length === 1) {\n        let firstArg = args[0];\n\n        typeCheck(firstArg, RNUM_T);\n\n        return {value: 1 / firstArg.value,\n                type: RNUM_T};\n    } else if (args.length === 2) {\n        let firstArg = args[0];\n        let secondArg = args[1];\n\n        typeCheck(firstArg, RNUM_T);\n        typeCheck(secondArg, RNUM_T);\n\n        return {value: firstArg.value / secondArg.value,\n                type: RNUM_T};\n    }\n\n    args.forEach((cur) => typeCheck(cur, RNUM_T));\n    return {value: false, type: RBOOL_T};\n}\nfunction car(args) {\n    if (args.length !== 1) {\n        throw new Error('arity mismatch');\n    }\n\n    let firstArg = args[0];\n\n    typeCheck(firstArg, RLIST_T);\n\n    return firstArg.value.a;\n}\nfunction cdr(args) {\n    if (args.length !== 1) {\n        throw new Error('arity mismatch');\n    }\n\n    let firstArg = args[0];\n\n    typeCheck(firstArg, RLIST_T);\n\n    return firstArg.value.d;\n}\nfunction cons(args) {\n    if (args.length !== 2) {\n        throw new Error('arity mismatch');\n    }\n\n    let firstArg = args[0];\n    let secondArg = args[1];\n\n    // because BSL\n    typeCheck(secondArg, RLIST_T);\n\n    return {value: {a: firstArg, d: secondArg},\n            type: RLIST_T};\n}\nfunction list(args) {\n    return args.reverse().reduce((acc, arg) => ({value: {a: arg, d: acc},\n                                                       type: RLIST_T}),\n                                       {value: null,\n                                        type: RLIST_T});\n}\nfunction not(args) {\n    if (args.length !== 1) {\n        throw new Error('arity mismatch');\n    }\n\n    let firstArg = args[0];\n\n    return {value: firstArg.value === false,\n            type: RBOOL_T};\n}\nfunction iseqv(args) {\n    if (args.length !== 2) {\n        throw new Error('arity mismatch');\n    }\n\n    let firstArg = args[0];\n    let secondArg = args[1];\n\n    return {value: firstArg.value === secondArg.value,\n            type: RBOOL_T};\n}\nfunction and(args) {\n    return args.reduce((acc, cur) => {\n        return acc.value !== false ? cur : {value: false, type: RBOOL_T};\n    }, {value: true, type: RBOOL_T});\n\n}\nfunction or(args) {\n    return args.reduce((acc, cur) => {\n        return acc.value !== false ? acc : cur;\n    }, {value: true, type: RBOOL_T});\n\n}\nfunction rif(args) {\n    if (args.length !== 3) {\n        throw new Error('arity mismatch');\n    }\n\n    let firstArg = args[0];\n    let secondArg = args[1];\n    let thirdArg = args[2];\n\n    typeCheck(firstArg, RBOOL_T);\n\n    return firstArg.value ? secondArg : thirdArg;\n}\nfunction isnull(args) {\n    if (args.length !== 1) {\n        throw new Error('arity mismatch');\n    }\n\n    let firstArg = args[0];\n\n    return {value: firstArg.value === null && firstArg.type === RLIST_T,\n            type: RBOOL_T};\n}\nfunction iscons(args) {\n    if (args.length !== 1) {\n        throw new Error('arity mismatch');\n    }\n\n    let firstArg = args[0];\n\n    return {value: firstArg.value !== null && firstArg.type === RLIST_T,\n            type: RBOOL_T};\n}\nfunction equalsign(args) {\n    args.forEach((cur) => typeCheck(cur, RNUM_T));\n\n    let val = args.reduce((acc, cur) => {\n\n        if (acc.value === false) {\n            return {value: false, type: RBOOL_T};\n        }\n\n        return acc.value===cur.value ? acc : {value: false, type: RBOOL_T};\n    });\n\n    if (val.value === false){\n        return val;\n    } else {\n        return {value: true, type: RBOOL_T};\n    }\n}\nfunction gtsign(args) {\n    args.forEach((cur) => typeCheck(cur, RNUM_T));\n\n    let val = args.reduce((acc, cur) => {\n\n        if (acc.value === false) {\n            return {value: false, type: RBOOL_T};\n        }\n\n        return acc.value > cur.value ? acc : {value: false, type: RBOOL_T};\n    });\n\n    if (val.value === false){\n        return val;\n    } else {\n        return {value: true, type: RBOOL_T};\n    }\n}\nfunction gesign(args) {\n    args.forEach((cur) => typeCheck(cur, RNUM_T));\n\n    let val = args.reduce((acc, cur) => {\n\n        if (acc.value === false) {\n            return {value: false, type: RBOOL_T};\n        }\n\n        return acc.value >= cur.value ? acc : {value: false, type: RBOOL_T};\n    });\n\n    if (val.value === false){\n        return val;\n    } else {\n        return {value: true, type: RBOOL_T};\n    }\n}\nfunction ltsign(args) {\n    args.forEach((cur) => typeCheck(cur, RNUM_T));\n\n    let val = args.reduce((acc, cur) => {\n\n        if (acc.value === false) {\n            return {value: false, type: RBOOL_T};\n        }\n\n        return acc.value < cur.value ? acc : {value: false, type: RBOOL_T};\n    });\n\n    if (val.value === false){\n        return val;\n    } else {\n        return {value: true, type: RBOOL_T};\n    }\n}\nfunction lesign(args) {\n    args.forEach((cur) => typeCheck(cur, RNUM_T));\n\n    let val = args.reduce((acc, cur) => {\n\n        if (acc.value === false) {\n            return {value: false, type: RBOOL_T};\n        }\n\n        return acc.value <= cur.value ? acc : {value: false, type: RBOOL_T};\n    });\n\n    if (val.value === false){\n        return val;\n    } else {\n        return {value: true, type: RBOOL_T};\n    }\n}\n\nexport {interp, parseCheck, unparse_cons, unparse_list, initEnv,\n        RVAR_T, RAPP_T, RFUNCT_T, RNUM_T, RBOOL_T, RSTRING_T, RLIST_T, RSYM_T,\n        varRE};\n","import {RBOOL_T} from './interpreter.js';\n\n/************\n    Colors\n************/\n\n// value to put in child formulas that don't have an output for that row\nexport const gray = {gray: 'gray'};\n// value to put in child formulas that have an error output for that row (non-boolean and non-gray)\nexport const pink = {pink: 'pink'};\n// value that indicates an uninitialized input\nexport const yellow = {yellow: 'yellow'};\n\n/*********************\n   Functions I Want\n*********************/\n// [Program] -> Boolean\n// returns true if progs has at least one member and all of its members are boooleans\n//    otherwise returns false\nexport function allBools(progs){\n    if (progs.length === 0) {\n        return false;\n    }\n\n    return progs.every((prog) => prog.type === RBOOL_T || prog === gray);\n}\n\nexport function isBooleanFormula(formula) {\n    return allBools(formula.outputs) || formula.thenChildren !== undefined;\n}\n\n","import {yellow, isBooleanFormula} from './header.js';\n\n/*********************\n    Pretty Printer\n*********************/\n\n/***\n  Data Definitions\n  \n  A Doc is one of\n    - Nil\n    - Compose\n    - Nest\n    - Text\n    - Line\n    - Union\n  \n  A Nil is\n    {type: 'nil'}\n    \n  A Compose is\n    {type: 'compose',\n     left: Doc,\n     right: Doc}\n     \n  A Nest is\n    {type:   'nest',\n     indent: Integer,\n     rest:   Doc}\n\n  A Text is\n     {type: 'text',\n      text: String}\n      \n  A Line is\n    {type: 'line'}\n     \n  A Union is\n    {type:  'union',\n     left:  Doc,\n     right: Doc}\n     \n  A Pair is\n    {doc:    Doc,\n     indent: Integer}\n***/\n\n// Doc\nconst nil = {type: 'nil'};\n\n// String -> Doc\nfunction text (string) {\n    if (string === '') {\n        return nil;\n    } else {\n        return {type: 'text', text: String(string)};\n    }\n}\n\n// String -> Doc -> Doc\nfunction Text (string, doc) {\n    return compose(text(string), doc);\n}\n\n// Doc\nconst line = {type: 'line'};\n\n// Integer -> Doc -> Doc\nfunction Line (i, doc) {\n    return compose(nest(i, line), doc);\n}\n\n// Doc -> Doc -> Doc\nfunction union (docL, docR) {\n    return {type: 'union', left: docL, right: docR};\n}\n\nfunction Union (docL, docR) {\n    return union(docL, docR);\n}\n\n// Doc -> Doc -> Doc\n// in the paper this is written as <> and is sometimes called 'concatenate'\n//   I prefer the name 'compose' so as to confuse the term with\n//   string concatenation\n// however it may be confused with function composition...\nfunction compose (docL, docR) {\n    // switch(docR.type) {\n    // case 'union':\n    //     return union(compose(docL, docR.left), compose(docL, docR.right));\n    // default:\n    //     break;\n    // }\n    switch (docL.type) {\n    case 'nil':\n        return docR;\n    case 'compose':\n        return {type: 'compose', left: docL.left, right: compose(docL.right, docR)};\n    case 'union':\n        return union(compose(docL.left, docR), compose(docL.right, docR));\n    default:\n        return {type: 'compose', left: docL, right: docR};\n    }\n}\n\n// Integer -> Doc -> Doc\nfunction nest (i, doc) {\n    switch (doc.type) {\n    case 'nil':\n        return nil;\n    case 'compose':\n        return compose(nest(i, doc.left), nest(i, doc.right));\n    case 'nest':\n        return {type: 'nest', indent: doc.indent + i, rest: doc.rest};\n    case 'text':\n        return doc;\n    case 'line':\n        return {type: 'nest', indent: i, rest: doc};\n    case 'union':\n        return union(nest(i, doc.left), nest(i, doc.right));\n    default:\n        throw Error(`unnexpected document type: ${doc.type}`);\n    }\n}\n\n// Doc -> String\nfunction layout (doc) {\n    switch (doc.type) {\n    case 'nil':\n        return '';\n    case 'compose':\n        return layout(doc.left) + layout(doc.right);\n    case 'nest':\n        return layout(doc.rest) +  ' '.repeat(doc.indent); // doc.rest has to be a line\n    case 'text':\n        return doc.text;\n    case 'line':\n        return '\\n';\n    default:\n        throw Error(`unnexpected document type: ${doc.type}`);\n    }\n}\n\n// Doc -> Doc\nfunction group (doc) {\n    return union(flatten(doc), doc);\n}\n\n// Doc -> Doc\nfunction flatten (doc) {\n    switch (doc.type) {\n    case 'nil':\n        return nil;\n    case 'compose':\n        return compose(flatten(doc.left), flatten(doc.right));\n    case 'nest':\n        return flatten(doc.rest);\n    case 'text':\n        return text(doc.text);\n    case 'line':\n        return text(' ');\n    case 'union':\n        return flatten(doc.left);\n    default:\n        throw Error(`unnexpected document type: ${doc.type}`);\n    }\n}\n\n// Integer -> Integer -> (Doc -> String)\nfunction makePretty (width, ribbon) {\n\n    // Integer -> Integer -> Doc -> Doc\n    function best (thisRibbon, current, doc) {\n        switch (doc.type) {\n        case 'nil':\n            return nil;\n        case 'compose':\n            switch (doc.left.type) {\n            case 'text':\n                return compose(doc.left, best(thisRibbon, current + doc.left.text.length, doc.right));\n            case 'line':\n                return compose(line, best(ribbon, 0, doc.right));\n            case 'nest':\n                return compose(nest(doc.left.indent, line), best(ribbon + doc.left.indent, doc.left.indent, doc.right));\n            default:\n                throw Error(`unnexpected document type: ${doc.left.type}`);\n            }\n        case 'union':\n            return better(thisRibbon, current,\n                          best(thisRibbon, current, doc.left),\n                          best(thisRibbon, current, doc.right));\n        default:\n            throw Error(`unnexpected document type: ${doc.type}`);\n        }\n    }\n\n    // Integer -> Integer -> Integer -> Doc -> Doc -> Doc\n    function better (thisRibbon, current, docL, docR) {\n        if (fits(width - current, thisRibbon - current, docL)) {\n            return docL;\n        } else {\n            return docR;\n        }\n    }\n\n    // Integer -> Integer -> Doc -> Boolean\n    function fits(deltaWidth, deltaRibbon, doc) {\n        if (deltaWidth < 0 || deltaRibbon < 0) {\n            return false;\n        }\n\n        switch (doc.type) {\n        case 'nil':\n            return true;\n        case 'compose':\n            switch (doc.left.type) {\n            case 'text':\n                return fits(deltaWidth - doc.left.text.length, deltaRibbon - doc.left.text.length, doc.right);\n            case 'line':\n                return true;\n            default:\n                throw Error(`unnexpected document type: ${doc.left.type}`);\n            }\n        default:\n            throw Error(`unnexpected document type: ${doc.type}`);\n        }\n    }\n\n    // Doc -> String\n    function pretty (doc) {\n        return layout(best(ribbon, 0, doc));\n    }\n\n    return pretty;\n}\n\n/***\n   Utility Functions\n                   ***/\n\n// Doc -> Doc -> Doc\nfunction putSpace (docL, docR) {\n    return compose(docL, compose(text(' '), docR));\n}\n\n// Doc -> Doc -> Doc\nfunction putLine (docL, docR) {\n    return compose(docL, compose(line, docR));\n}\n\n// Doc -> Doc -> Doc\nfunction spaceOrLine(docL, docR) {\n    return union(putSpace(docL, docR), putLine(docL, docR));\n}\n\n// (Doc -> Doc -> Doc) -> [Doc] -> Doc\nfunction folddoc (f, docs) {\n    if (docs.length === 0) {\n        return nil;\n    } else if (docs.length === 1) {\n        return docs[0];\n    } else {\n        return f(docs[0], folddoc(f, docs.splice(1)));\n    }\n}\n\n// [Doc] -> Doc\n// puts a space between docs\nfunction spread (docs) {\n    return folddoc(putSpace, docs);\n}\n\n// [Doc] -> Doc\n// puts a line between docs\nfunction stack (docs) {\n    return folddoc(putLine, docs);\n}\n\n// [Doc] -> Doc\n// puts more lines between docs\nfunction superstack (docs) {\n    return folddoc((docL, docR) => compose(docL, compose(line, compose(line, compose(line, docR)))), docs);\n}\n\n// [Doc] -> Doc\n// fills available horizontal space\n// doesn't work in group()s because group() destroys unions\nfunction fill(docs){\n    return folddoc(spaceOrLine, docs);\n}\n\n// [Doc] -> Doc\n// puts docs right next to eachother\nfunction level (docs) {\n    return folddoc(compose, docs);\n}\n\n/**************************************\n    Thing that Turns Tables Into BSL\n**************************************/\n\n// [Table] -> String\nfunction toBSL(program, unparse, width, ribbon) {\n    let pretty = makePretty(width, ribbon);\n    let essaie = superstack([...program.map(tableToDoc), nil]);\n    return pretty(essaie);\n\n    // Table -> Doc\n    function tableToDoc(table) {\n        let name = inputToDoc(table.name);\n        let params = spread(table.params.map((param) => inputToDoc(param.name)));\n\n        let checkExpects = stack(table.examples.map((example) => {\n            let inputs = stack(example.inputs.map((input) => inputToDoc(input.prog)));\n            let want = inputToDoc(example.want);\n\n            return group(nest(1, stack([text('(check-expect'), nest(1, stack([level([text('('), name]), level([inputs, text(')')])])), level([want, text(')')])])));\n        }));\n\n        let body = stack(table.formulas.map(formulaToDoc));\n        let funct = nest(2, group(stack([spread([text('(define'), level([text('('), name]), level([params, text(')')])]), level([body, text(')')])])));\n        return stack([funct, line, checkExpects]);\n    }\n\n    // Formula -> Doc\n    function formulaToDoc(formula) {\n        if (isBooleanFormula(formula)) {\n            let children = spread(formula.thenChildren.map(formulaToDoc));\n            return nest(2, stack([text('(cond'), nest(1, stack([level([text('['), inputToDoc(formula.prog)]), level([children, text('])')])]))]));\n        } else {\n            return inputToDoc(formula.prog);\n        }\n    }\n\n    // Input (yellow or string or program) -> Doc\n    function inputToDoc(input) {\n        if (input === yellow) { // empty\n            return text('...');\n        } else if (typeof input === 'string') { // string\n            return text(input);\n        } else { // program\n            return text(unparse(input));\n        }\n    }\n}\n\n\nexport default toBSL;\n","import React from 'react';\nimport {interp, parseCheck, unparse_cons, unparse_list, initEnv, RAPP_T, RFUNCT_T, RBOOL_T, RLIST_T, varRE} from './interpreter.js';\nimport {gray, pink, yellow, allBools, isBooleanFormula} from './header.js';\nimport toBSL from './prettyprint.js';\nimport './App.css';\n\n/*****************************\n  Universal Constants I Want\n*****************************/\n// value to indicate a dry run, i.e. don't actually change the underlying structure, just say\n// if the given value exists or not\nconst dryRun = {yo: 'don\\'t actually change anything'};\n// image path\nconst imgPath = './images/';\n\n\n/*********************\n    Key Management\n*********************/\n// variable used by takeKey and peekKey to generate keys\nlet keyCount = 0;\n\n// Number\n// returns a unique key\nfunction takeKey() {\n    return keyCount++;\n}\n\n// [Number] -> Number (the brackets here mean optional, not array)\n// returns current key without changing it\n// shoud be used to look at current state of key without actually taking it\n// optionally takes a number as an argument, in which case it returns the key that number\n// of steps ahead of the current key\nfunction peekKey(lookahead) {\n    if (lookahead === undefined) {\n        return keyCount;\n    } else {\n        return keyCount + lookahead;\n    }\n}\n\n/**************\n    Globals\n**************/\nlet unparse = unparse_cons;\nlet showBSL = false;\n\n/*****************\n    Deep Equals\n*****************/\n// Program -> Program -> Boolean\n// checks if two programs are equivalent, recurs on lists and applications\n// may not quite work on functions because I use js functions, not data represented closures or something\n//    thus 2 functions are only equal if they're a reference to the same object\nfunction deepEquals(proga, progb) {\n    if (proga.type !== progb.type) {\n        return false;\n    }\n\n    if (proga.type === RLIST_T) {\n        if (proga.value === null || progb.value === null) {\n            return proga.value === progb.value;\n        }\n        return deepEquals(proga.value.a, progb.value.a) && deepEquals(proga.value.d, progb.value.d);\n    }\n\n    // this case will prolly never even happen...\n    if (proga.type === RAPP_T) {\n        if (proga.value.args.length !== progb.value.args.length) {\n            return false;\n        }\n        let functCheck = deepEquals(proga.value.funct, progb.value.funct);\n        let argCheck = proga.value.args.map((arga, i) => deepEquals(arga, progb.value.args[i])).every((elem) => elem);\n        return functCheck && argCheck;\n    }\n\n    return proga.value === progb.value;\n}\n\n/*********************\n   React Components\n*********************/\n\n/*** Buttons ***/\n// Button that probably removes something\nfunction RemButton(props){\n    return (\n        <div className='cross_button'>\n          <input\n            type={'image'}\n            style={props.style}\n            src={'./images/smallCross.png'}\n            alt='Remove'\n            title={props.title}\n            onClick={props.onClick}/>\n        </div>\n    );\n}\n\n/*** Inputs ***/\nclass ValidatedInput extends React.Component {\n    constructor(props) {\n        super(props);\n        this.state = {text: ''};\n\n        this.textChange = this.textChange.bind(this);\n    }\n\n    textChange(e) {\n        let text = e.target.value;\n\n        this.setState((state) => ({text}));\n\n        if (this.props.isValid(text)) {\n            this.props.onValid(text);\n        } else if (text === '' && !this.props.dummy) {\n            this.props.onEmpty();\n        }\n\n    }\n\n    render() {\n        let className;\n        if (this.props.dummy && this.state.text === '') { // empty dummy\n            className = 'dummy_input';\n        } else if (this.props.isValid(this.state.text)) { // valid\n            className = 'valid_input';\n        } else if (this.state.text === '') { // empty non-dummy\n            className = 'empty_input';\n        } else { // invalid\n            className = 'invalid_input';\n        }\n        \n        let size;\n        if (this.state.text.length === 0)\n            size = this.props.placeholder.length;\n        else\n            size = Math.max(this.state.text.length + 2, 4);\n\n        return (\n            <input\n              className={className}\n              size={size}\n              placeholder={this.props.placeholder}\n              type={'text'}\n              value={this.state.text}\n              onChange={this.textChange}\n            />\n        );\n    }\n}\n\n/*** Table Sections ***/\n// let's put everything in one table woo\nfunction Succinct(props) {\n\n    function tableChange(newTab, oldTab) {\n        const exists = props.tables.indexOf(oldTab) !== -1;\n\n        let alteredTabs;\n        if (exists) {\n            alteredTabs = props.tables.map((table) => table === oldTab ? newTab : table);\n        } else {\n            alteredTabs = [...props.tables, newTab];\n        }\n\n        props.programChange(alteredTabs);\n    }\n\n    function remTable(deadTab) {\n        let aliveTabs = props.tables.filter((table) => table !== deadTab);\n        props.programChange(aliveTabs);\n    }\n\n    // String -> Boolean\n    function validName(text, modTab) {\n        function lookup(name, env) {\n            return env.reduce((acc, variable) => {\n                if (acc) {\n                    return true;\n                }\n\n                return variable.name === name;\n\n            }, false);\n        }\n\n        let tableVars = props.tables.filter((table) => table !== modTab).map((otherTab) => ({name: otherTab.name, binding: null}));\n        let paramVars = modTab.params.map((param) => ({name: param, binding: null}));\n        let env = [...initEnv, ...tableVars, ...paramVars];\n\n        return varRE.test(text) && !lookup(text, env);\n    }\n\n    const reals = props.tables.map((table) => (\n        <div key={table.key} className='table_method' >\n          <div className='full_cell'>\n            <ValidatedInput\n              dummy={false}\n              placeholder='Table Name'\n              isValid={(text) => validName(text, table)}\n              onValid={(text) => tableChange({...table,\n                                              name: text},\n                                             table)}\n              onEmpty={() => tableChange({...table,\n                                          name: yellow},\n                                         table)}\n            />\n            <RemButton\n              onClick={() => remTable(table)}\n              title='Remove this table'\n            />\n          </div>\n          <SuccinctTab\n            table={table}\n            tableNames={props.tables.map((table) => table.name)}\n            tableChange={(newTab) => tableChange(newTab, table)}\n          />\n        </div>\n    ));\n\n    const dummy = (\n        <div key={peekKey()} className='table_method'>\n          <div className='full_cell'>\n            <ValidatedInput\n              dummy={true}\n              placeholder='Table Name'\n              isValid={(text) => validName(text, {params: []})}\n              onValid={(text) => tableChange({name: text,\n                                              examples: [],\n                                              formulas: [],\n                                              params: [],\n                                              key: takeKey()},\n                                             {})}\n            />\n          </div>\n          <SuccinctTab\n            table={{name: yellow,\n                    examples: [],\n                    formulas: [],\n                    params: [],\n                    key: peekKey()}}\n            tableNames={props.tables.map((table) => table.name)}\n            tableChange={(newTab) => tableChange(newTab, {})}\n          />\n        </div>\n    );\n\n    return (\n        <div>\n          {[...reals, dummy]}\n        </div>\n    );\n}\n\nfunction SuccinctTab(props) {\n    function paramsExamplesChange(params, examples) {\n        props.tableChange({...props.table, params, examples});\n    }\n\n    function formulasChange(formulas) {\n        props.tableChange({...props.table, formulas});\n    }\n\n    function examplesFormulasChange(examples, formulas) {\n        props.tableChange({...props.table, examples, formulas});\n    }\n\n    return (\n        <table className={'html_table'}>\n          <SuccinctHead\n            params={props.table.params}\n            examples={props.table.examples}\n            tableNames={props.tableNames}\n            paramsExamplesChange={paramsExamplesChange}\n\n            formulas={props.table.formulas}\n            formulasChange={formulasChange}\n          />\n          <SuccinctBody\n            examples={props.table.examples}\n            formulas={props.table.formulas}\n            paramNames={props.table.params.map((param) => param.name)}\n            examplesFormulasChange={examplesFormulasChange}\n            formulasChange={formulasChange}\n          />\n        </table>\n    );\n}\n\nfunction SuccinctHead(props) {\n    // String -> Boolean\n    // checks if the given string is a valid program\n    function validProg(text) {\n        let isgood = true;\n\n        try {\n            parseCheck(text);\n        } catch(e) {\n            if (e instanceof SyntaxError) {\n                isgood = false;\n            } else { // this should never happen\n                throw e;\n            }\n        }\n\n        return isgood;\n    }\n\n    // Formula -> Side Effect\n    // removes a given formula from the tree\n    function remFormula(deadForm) {\n        const aliveForms = props.formulas.filter((formula) => formula !== deadForm);\n        props.formulasChange(aliveForms);\n    }\n\n    // Formula -> Formula -> Side Effect\n    // replaces one formula with another one\n    function formulaChange(newForm, oldForm) {\n\n        let alteredForms;\n        if (props.formulas.indexOf(oldForm) === -1) {\n            alteredForms = [...props.formulas, newForm];\n        } else {\n            alteredForms = props.formulas.map((form) => form === oldForm ? newForm : form);\n        }\n        props.formulasChange(alteredForms);\n    }\n\n    // Formula -> Number -> Number\n    // gives the maximum depth of a Formula, second parameter is an accumulator\n    function maxDepth(formula, curMax) {\n        if (!isBooleanFormula(formula)) {\n            return curMax;\n        } else {\n            return formula.thenChildren.reduce((acc, child) => Math.max(acc, maxDepth(child, curMax + 1)), curMax + 1);\n        }\n    }\n\n    function countWidth(formula) {\n        if (!isBooleanFormula(formula)) {\n            return 1;\n        } else {\n            return formula.thenChildren.reduce((acc, child) => acc + countWidth(child), 2);\n        }\n    }\n\n\n    // Number -> [Number]\n    // takes a number, returns an array that counts from 1 to that number, input of 0 gives empty array\n    // e.g. countUp(5) -> [1, 2, 3, 4, 5]\n    function countUp(num) {\n        // special case: want an empty array for 0\n        if (num === 0) {\n            return [];\n        } else if (num === 1)\n            return [1];\n        else\n            return [...countUp(num - 1), num];\n    }\n\n    const abyss = props.formulas.reduce((acc, formula) => Math.max(acc, maxDepth(formula, 0)), 0);\n    const numParams = props.params.length;\n\n    const reals = props.formulas.map((formula) => (\n        <th key={formula.key} colSpan={countWidth(formula)} >\n          <div className='full_cell'>\n            <ValidatedInput\n              placeholder={'Formula'}\n              dummy={false}\n              isValid={validProg}\n              onValid={(text) => formulaChange({...formula,\n                                                prog: parseCheck(text)},\n                                               formula)}\n              onEmpty={() => formulaChange({...formula,\n                                            prog: yellow},\n                                           formula)}\n            />\n            <RemButton\n              title={'Remove formula'}\n              onClick={() => remFormula(formula)}\n            />\n          </div>\n        </th>\n    ));\n\n    const dummy = (\n        <th key={peekKey()} colSpan={1}>\n          <div className='full_cell'>\n            <ValidatedInput\n              dummy={true}\n              placeholder='Formula'\n              isValid={validProg}\n              onValid={(text) => formulaChange({prog: parseCheck(text),\n                                                outputs: props.examples.map((_) => yellow),\n                                                key: takeKey()},\n                                               {})}\n            />\n          </div>\n        </th>\n    );\n\n    const children = countUp(abyss).map((depth) => (\n        <tr key={depth}>\n          <th colSpan={numParams + 2}>{/* empty cell to align with example RemButton and Parameters */}</th>\n          {props.formulas.map((formula) => (\n              <DepictFormula\n                key={formula.key}\n                formula={formula}\n                depth={depth}\n                numExamples={props.examples.length}\n                formulaChange={(newForm) => formulaChange(newForm, formula)}\n              />\n          ))}\n        </tr>\n    ));\n\n    return (\n        <thead>\n          <tr>\n            <Parameters\n              params={props.params}\n              examples={props.examples}\n              tableNames={props.tableNames}\n              paramsExamplesChange={props.paramsExamplesChange}\n            />\n            {/* top level formulas */}\n            {[...reals, dummy]}\n          </tr>\n          {/* rest of formulas */}\n          {children}\n        </thead>\n    );\n}\n\nfunction Parameters(props) {\n    // \n    function validParam(text, modParam) {\n        function lookup(name, env) {\n            return env.reduce((acc, variable) => {\n                if (acc) {\n                    return true;\n                }\n\n                return variable.name === name;\n\n            }, false);\n        }\n\n        // These are not technically Variables, see note above\n        let paramVars = props.params.filter((param) => param !== modParam).map((param) => ({name: param.name, binding: null}));\n        let tableVars = props.tableNames.map((name) => ({name: name, binding: null}));\n        let env = [...initEnv, ...tableVars, ...paramVars];\n\n        return varRE.test(text) && !lookup(text, env);\n    }\n\n    function remParam(deadParam) {\n        const deadIndex = props.params.indexOf(deadParam);\n        const aliveParams = props.params.filter((param) => param !== deadParam);\n\n        // need to maintain #inputs = #params\n        const modExamples = props.examples.map((example => ({...example,\n                                                             inputs: example.inputs.filter((_, i) => i !== deadIndex)})));\n\n        props.paramsExamplesChange(aliveParams, modExamples);\n    }\n\n    // String -> Number -> Side Effect\n    // changes the name of the given parameter\n    // if that parameter doesn't exist yet, it makes it\n    function paramChange(newParam, modParam) {\n\n        let alteredParams, alteredExamples;\n        if (props.params.indexOf(modParam) === -1) {\n            alteredParams = [...props.params, newParam];\n            // need to maintain #inputs = #params\n            alteredExamples = props.examples.map((example) => ({...example,\n                                                                inputs: [...example.inputs, {prog: yellow, key: takeKey()}]}));\n        } else {\n            alteredParams = props.params.map((param) => param === modParam ? newParam : param);\n            // examples don't actually change\n            alteredExamples = props.examples;\n        }\n\n        props.paramsExamplesChange(alteredParams, alteredExamples);\n    }\n\n    const reals = props.params.map((param) => (\n        <th key={param.key} >\n          <div className='full_cell'>\n            <ValidatedInput\n              dummy={false}\n              placeholder='Parameter'\n              isValid={(text) => validParam(text, param)}\n              onValid={(text) => paramChange({...param,\n                                              name: text},\n                                             param)}\n              onEmpty={() => paramChange({...param,\n                                          name: yellow},\n                                         param)}\n            />\n            <RemButton\n              title='remove this parameter'\n              onClick={() => remParam(param)}\n            />\n          </div>\n        </th>\n    ));\n\n    const dummy = (\n        <th key={peekKey()}>\n          <div className='full_cell'>\n            <ValidatedInput\n              dummy={true}\n              placeholder='Parameter'\n              isValid={(text) => validParam(text, {})}\n              onValid={(text) => paramChange({name: text,\n                                              key: takeKey()},\n                                             {})}\n            />\n          </div>\n        </th>\n    );\n\n    return (\n        <React.Fragment>\n          <th>{/* empty cell to align with example RemButtons */}</th>\n          <React.Fragment>\n            {[...reals, dummy]}\n          </React.Fragment>\n        </React.Fragment>\n    );\n}\n\n/*\n  props: formula, depth, kill, formulaChange\n*/\nfunction DepictFormula(props) {\n    function validProg(text) {\n        let isgood = true;\n\n        try {\n            parseCheck(text);\n        } catch(e) {\n            if (e instanceof SyntaxError) {\n                isgood = false;\n            } else {\n                throw e;\n            }\n        }\n\n        return isgood;\n    }\n\n    // this is pretty macabre...\n    function remChild(deadChild) {\n        const aliveChildren = props.formula.thenChildren.filter((child) => child !== deadChild);\n        props.formulaChange({...props.formula, thenChildren: aliveChildren});\n    }\n\n    function childChange(newChild, modChild) {\n        let children;\n        if (props.formula.thenChildren.indexOf(modChild) === -1) {\n            children = [...props.formula.thenChildren, newChild];\n        } else {\n            children = props.formula.thenChildren.map((child) => child === modChild ? newChild : child);\n        }\n        props.formulaChange({...props.formula, thenChildren: children});\n    }\n\n    function countWidth(formula) {\n        if (!isBooleanFormula(formula)) {\n            return 1;\n        } else {\n            return formula.thenChildren.reduce((acc, child) => acc + countWidth(child), 2);\n        }\n    }\n\n    if (props.depth > 1) {\n        return (\n            <React.Fragment>\n              <th>{/* empty cell to align with parent input */}</th>\n              {isBooleanFormula(props.formula) ?\n               <React.Fragment>\n                 {props.formula.thenChildren.map((child) => (\n                     <DepictFormula\n                       key={child.key}\n                       formula={child}\n                       depth={props.depth - 1}\n                       numExamples={props.numExamples}\n                       formulaChange={(formula) => childChange(formula, child)}\n                     />))}\n                 <th>{/* empty cell to align with child input */}</th>\n               </React.Fragment>\n               : <script/> }\n            </React.Fragment>\n        );\n    } else {\n        if (isBooleanFormula(props.formula)) {\n            const reals = props.formula.thenChildren.map((child) => (\n                <th key={child.key} colSpan={countWidth(child)} >\n                  <div className='full_cell'>\n                    <ValidatedInput\n                      dummy={false}\n                      placeholder={'Formula'}\n                      isValid={validProg}\n                      onValid={(text) => childChange({...child,\n                                                      prog: parseCheck(text)},\n                                                     child)}\n                      onEmpty={() => childChange({...child,\n                                                  prog: yellow},\n                                                 child)}\n                    />\n                    <RemButton\n                      title={'Remove formula'}\n                      onClick={() => remChild(child)}\n                    />\n                  </div>\n                </th>\n            ));\n\n            const dummy = (\n                <th key={peekKey()} colSpan={1}>\n                  <div className='full_cell'>\n                    <ValidatedInput\n                      dummy={true}\n                      placeholder='Formula'\n                      isValid={validProg}\n                      onValid={(text) => childChange({prog: parseCheck(text),\n                                                      outputs: Array(props.numExamples).fill(yellow),\n                                                      key: takeKey()},\n                                                     {})}\n                    />\n                  </div>\n                </th>\n            );\n\n            return (\n                <React.Fragment>\n                  <th>{/* empty cell to align with parent input */}</th>\n                   <React.Fragment>\n                     {[...reals, dummy]}\n                   </React.Fragment>\n                </React.Fragment>\n            );\n        } else {\n\n            return (\n                <React.Fragment>\n                  <th>{/* empty cell to align with parent input */}</th>\n                </React.Fragment>\n            );\n        }\n    }\n}\n\nfunction SuccinctBody(props) {\n    function remExample(deadExample) {\n        const deadIndex = props.examples.indexOf(deadExample);\n        // Formula -> Formula\n        // removes the output at deadIndex from the given formula and all of its children (if it has any) so stuff works\n        function removeOutputFromFormula(formula) {\n            let outputs = formula.outputs.filter((_, i) => i !== deadIndex);\n\n            if (isBooleanFormula(formula)) {\n                const thenChildren = formula.thenChildren.map(removeOutputFromFormula);\n                return {...formula,\n                        outputs,\n                        thenChildren};\n            } else {\n                return {...formula,\n                        outputs};\n            }\n        }\n\n\n        const aliveExamples = props.examples.filter((example) => example !== deadExample);\n        const alteredForms = props.formulas.map(removeOutputFromFormula);\n        props.examplesFormulasChange(aliveExamples, alteredForms);\n    }\n\n    function exampleChange(newExample, oldExample) {\n        const exists = props.examples.indexOf(oldExample) !== -1;\n\n        if (newExample === dryRun) {\n            return exists;\n        }\n\n        // Formula -> Formula\n        // adds an init output to the given formula and all of its children (if it has any) so stuff works\n        function addAnotherOutputToFormula(formula) {\n            let outputs = [...formula.outputs, yellow];\n\n            if (isBooleanFormula(formula)) {\n                const thenChildren = formula.thenChildren.map(addAnotherOutputToFormula);\n                return {...formula,\n                        outputs,\n                        thenChildren};\n            } else {\n                return {...formula,\n                        outputs};\n            }\n        }\n\n        let alteredExamples, alteredForms;\n        if (exists) {\n            alteredExamples = props.examples.map((example) => example === oldExample ? newExample : example);\n            alteredForms = props.formulas;\n        } else {\n            alteredExamples = [...props.examples, newExample];\n            alteredForms = props.formulas.map(addAnotherOutputToFormula);\n        }\n\n        props.examplesFormulasChange(alteredExamples, alteredForms);\n        return true; // this doesn't actually do anything\n    }\n\n    const reals = props.examples.map((example, i) => (\n          <tr key={example.key}>\n            <td>\n              <RemButton\n                onClick={() => remExample(example)}\n                title={'Remove this example'}\n              />\n            </td>\n            <Inputs\n              dummy={false}\n              inputs={example.inputs}\n              inputsChange={(inputs) => exampleChange({...example, inputs},\n                                                      example)}\n            />\n            <td>{/* empty cell to align with param dummy input */}</td>\n            <Outputs\n              dummy={false}\n              formulas={props.formulas}\n              want={example.want}\n              row={i}\n            />\n            <td>{/* empty cell to align with top level formula dummy input */}</td>\n            <Want\n              dummy={false}\n              wantChange={(want) => exampleChange({...example, want},\n                                                  example)}\n            />\n          </tr>\n    ));\n    \n    const dummy = (\n          <tr key={peekKey(props.paramNames.length)}>\n            <td>{/* empty cell to offset rembutton */}</td>\n            <Inputs\n              dummy={true}\n              inputs={props.paramNames.map((_, i) => ({key: peekKey(i)}))}\n              inputsChange={(inputs) => exampleChange({inputs,\n                                                       want: yellow,\n                                                       key: takeKey()},\n                                                      {})}\n            />\n            <td>{/* empty cell to align with param dummy input */}</td>\n            <Outputs\n              dummy={true}\n              formulas={props.formulas}\n            />\n            <td>{/* empty cell to align with top level formula dummy input */}</td>\n            <Want\n              dummy={true}\n              wantChange={(want) => exampleChange({want,\n                                                   inputs: props.paramNames.map((_) => ({prog: yellow, key: takeKey()})),\n                                                   key: takeKey()},\n                                                  {})}\n            />\n          </tr>\n    );\n\n    return (\n        <tbody>\n          {[...reals, dummy]}\n        </tbody>\n    );\n}\n\nfunction Inputs(props) {\n    function validProg(text) {\n        try {\n            interp(parseCheck(text), initEnv);\n        } catch(e) {\n            return false;\n        }\n        return true;\n    }\n\n    function inputChange(newInput, oldInput) {\n        let alteredInputs;\n        if (props.dummy) {\n            alteredInputs = props.inputs.map((input) => input === oldInput ? {...newInput, key: takeKey()} : {prog: yellow, key: takeKey()});\n        } else {\n            alteredInputs = props.inputs.map((input) => input === oldInput ? newInput : input);\n        }\n        props.inputsChange(alteredInputs);\n    }\n\n    return (\n        <React.Fragment>\n          {props.inputs.map((input, i) => (\n              <td key={input.key} >\n                <ValidatedInput\n                  dummy={props.dummy}\n                  placeholder={'Input'}\n                  isValid={validProg}\n                  onValid={props.dummy ?\n                           (text) => inputChange({prog: parseCheck(text)},\n                                                  input)\n                           :\n                           (text) => inputChange({...input,\n                                                  prog: parseCheck(text)},\n                                                 input)}\n                  \n                  onEmpty={() => inputChange({...input,\n                                              prog: yellow},\n                                             input)}\n                />\n              </td>\n          ))}\n        </React.Fragment>\n    );\n}\n\nfunction Outputs(props) {\n    function countWidth(formula) {\n        if (!isBooleanFormula(formula)) {\n            return 1;\n        } else {\n            return formula.thenChildren.reduce((acc, child) => acc + countWidth(child), 2);\n        }\n    }\n\n    if (props.dummy) {\n        return (\n            <React.Fragment>\n            {props.formulas.map((formula) => (\n                <td key={formula.key} colSpan={countWidth(formula)}>{/* empty cell */}</td>\n            ))}\n            </React.Fragment>\n        );\n    } else {\n        return (\n            <React.Fragment>\n              {props.formulas.map((formula) => (\n                  <React.Fragment key={formula.key}>\n                    <TestCell\n                      output={formula.outputs[props.row]}\n                      want={props.want}\n                    />\n                    {isBooleanFormula(formula) ?\n                     <React.Fragment>\n                       <Outputs\n                         formulas={formula.thenChildren}\n                         want={props.want}\n                         row={props.row}\n                       />\n                       <td>{/* empty cell to align with dummy child */}</td>\n                     </React.Fragment>\n                     : <script/> }\n                  </React.Fragment>\n              ))}\n            </React.Fragment>\n        );\n    }\n}\n\nfunction TestCell(props) {\n\n    if (props.output === gray) {\n        return (\n            <td className={'gray'}>\n            </td>\n        );\n    }\n\n    if (props.output === pink) {\n        return (\n            <td className={'pink'}>\n            </td>\n        );\n    }\n\n    if (props.output === yellow) {\n        return (\n            <td className={'yellow'}>\n            </td>\n        );\n    }\n\n    let output = props.output;\n    let want = yellow;\n\n    if (props.want !== yellow) {\n        want = interp(props.want, initEnv);\n    }\n\n    let text, error;\n    if (output instanceof Error) {\n        text = output.message;\n        error = true;\n    } else {\n        text = unparse(output);\n        error = false;\n    }\n\n    let img;\n    if (error) {\n        img = <img\n                src={imgPath + 'frowneyface.png'}\n                alt='Error!'\n                style={{float: 'right'}}\n                title={\"Oh no! You got an error!\"}/>;\n    }else if (want === yellow) { // I should make this better\n        img = '';\n    } else if (deepEquals(output, want)) {\n        img =  <img\n                 src={imgPath + 'smileyface.png'}\n                 alt='Yay!'\n                 style={{float: 'right'}}\n                 title={\"Yay! It's right!\"}/>;\n    } else {\n        img = '';\n    }\n\n    return (\n        <td className={'output'}>\n          {text}\n          {img}\n        </td>\n    );\n}\n\nfunction Want(props) {\n    function validProg(text) {\n        try {\n            interp(parseCheck(text), initEnv);\n        } catch(e) {\n            return false;\n        }\n        return true;\n    }\n\n    return (\n        <td>\n          <ValidatedInput\n            dummy={props.dummy}\n            placeholder={'Want'}\n            isValid={validProg}\n            onValid={(text) => props.wantChange(parseCheck(text))}\n            onEmpty={() => props.wantChange(yellow)}\n          />\n        </td>\n    );\n}\n\n/*\n  notes:\n  #inputs === #params\n  #outputs === #examples\n  ---------------------\n  |#inputs !== #outputs| (well it can but not always)\n  ---------------------\n*/\n\nclass App extends React.Component {\n    constructor(props){\n        super(props);\n        let tables = [{examples: [{inputs: [{prog: yellow, key: takeKey()}], want: yellow, key: takeKey()}],\n                       formulas: [{prog: yellow, outputs: [yellow], key: takeKey()}],\n                       params: [{name: yellow, key: takeKey()}],\n                       name: yellow,\n                       key: takeKey()}];\n        this.state = {tables};\n\n        this.programChange = this.programChange.bind(this);\n    }\n\n    calculate(program) {\n        function makeLookup(table) {\n            function lookup(args) {\n                if (args.length !== table.params.length) {\n                    throw new Error('Arity Mismatch, expected ' + table.params.length + ' argument' + (table.params.length === 1 ? '' : 's'));\n                }\n\n                let expr = table.examples.reduce((acc, example) => {\n                    if (acc !== undefined) {\n                        return acc;\n                    }\n\n                    // I have no idea what should happen if this is called on a table with no params\n                    if (example.inputs.reduce((acc, input, i) => {\n                        return acc && deepEquals(input.prog, args[i]);\n                    }, true)) {\n                        if (example.want === yellow) {\n                            throw new ReferenceError(`(${table.name} ${args.map(unparse).join(' ')}) doesn't have a want`);\n                        } else {\n                            return example.want;\n                        }\n                    }\n\n                    return undefined;\n                }, undefined);\n\n                if (expr === undefined) {\n                    // it's like a reference error in the super meta table language\n                    throw new ReferenceError(args.map(unparse).join() + ' is not an example in ' + table.name);\n                }\n\n                return expr;\n            }\n\n            return lookup;\n        }\n\n        let lookups = program.map((table) => ({name: table.name, binding: {value: makeLookup(table), type: RFUNCT_T}}));\n        let globalEnv = [...initEnv, ...lookups];\n\n        function calcTable(table) {\n            function calcFormula(formula, examples) {\n                let outputs = examples.map((example) => {\n                    if (example === gray) {\n                        return gray;\n                    } else if (example === pink) {\n                        return pink;\n                    } else if (!example.inputs.every((input) => input.prog !== yellow) || formula.prog === yellow) {\n                        // if any of the inputs or the formula isn't initialized, return yellow\n                        return yellow;\n                    }\n\n                    let localEnv = table.params.map((param, i) => ({name: param.name, binding: interp(example.inputs[i].prog, initEnv)}));\n                    let env = [...globalEnv, ...localEnv];\n\n                    try {\n                        var output = interp(formula.prog, env);\n                    } catch (e) {\n                        output = e;\n                    }\n\n                    return output;\n                });\n\n                if (allBools(outputs) || (formula.thenChildren !== undefined && formula.thenChildren.length !== 0)) {\n                    function maybeSpecial(example, output) {\n                        if (example === gray || output.value === false)\n                            return gray;\n                        else if (typeof output.value !== 'boolean')\n                            return pink;\n                        else\n                            return example;\n                    }\n\n                    if (formula.thenChildren === undefined) {\n                        var thenChildren = [];\n                    } else {\n                        let subExamples = examples.map((example, i) => maybeSpecial(example, outputs[i]));\n                        thenChildren = formula.thenChildren.map((formula) => calcFormula(formula, subExamples));\n                    }\n\n                    return {...formula,\n                            outputs,\n                            thenChildren};\n                } else {\n                    let newFormula = {...formula,\n                                      outputs};\n                    delete newFormula.thenChildren;\n                    return newFormula;\n                }\n            }\n\n            if (table.name === yellow || !table.params.every((param) => param.name !== yellow)) {\n                // if the table or any of the table's parameters don't have a name yet, freeze outputs\n                return {...table}; \n            } else {\n                let formulas = table.formulas.map((formula) => calcFormula(formula, table.examples));\n                return {...table,\n                        formulas};\n            }\n\n        }\n\n        return program.map(calcTable);\n    }\n\n    programChange(newProg) {\n        let calkedProg = this.calculate(newProg);\n        //console.log(calkedProg);\n        //console.log('next key: ', peekKey());\n        this.setState((state) => {\n            return {tables: calkedProg};\n        });\n    }\n\n    render(){\n        let bslField;\n        if (showBSL) {\n            bslField = (\n                <textarea\n                  className='bsl_field'\n                  rows={20}\n                  cols={70}\n                  readOnly={true}\n                  value={toBSL(this.state.tables, unparse, 70, 50)}\n                />\n            );\n        } else {\n            bslField = (\n                <textarea\n                  className='bsl_field'\n                  rows={20}\n                  cols={70}\n                  readOnly={true}\n                  value={''}\n                />\n            );\n        }\n\n        return (\n            <div>\n              <div className='bsl_io'>\n                <div className='bsl_checkbox'>\n                  <input\n                    type='checkbox'\n                    id='bsl_output'\n                    name='bsl_output'\n                    onChange={(e) => {showBSL = !showBSL; this.setState((state) => state);}}\n                  />\n                  <label htmlFor='bsl_output'>Show BSL Output</label>\n                </div>\n                {bslField}\n              </div>\n              <Succinct\n                tables={this.state.tables}\n                programChange={this.programChange}\n              />\n              <div className='language_select'>\n                <select\n                  defaultValue='cons'\n                  onChange={(e) => {\n                      if (e.target.value === 'cons'){\n                          unparse = unparse_cons;\n                      } else {\n                          unparse = unparse_list;\n                      }\n                      // this just rerenders everything, the state remains unchanged\n                      this.setState((state) => state);\n                  }}\n                >\n                  <option value='cons'>Beginning Student</option>\n                  <option value='list'>Beginning Student with List Abbreviations</option>\n                </select>\n              </div>\n            </div>\n        );\n    }\n}\n\nexport default App;\n","// This optional code is used to register a service worker.\n// register() is not called by default.\n\n// This lets the app load faster on subsequent visits in production, and gives\n// it offline capabilities. However, it also means that developers (and users)\n// will only see deployed updates on subsequent visits to a page, after all the\n// existing tabs open on the page have been closed, since previously cached\n// resources are updated in the background.\n\n// To learn more about the benefits of this model and instructions on how to\n// opt-in, read https://bit.ly/CRA-PWA\n\nconst isLocalhost = Boolean(\n  window.location.hostname === 'localhost' ||\n    // [::1] is the IPv6 localhost address.\n    window.location.hostname === '[::1]' ||\n    // 127.0.0.1/8 is considered localhost for IPv4.\n    window.location.hostname.match(\n      /^127(?:\\.(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)){3}$/\n    )\n);\n\nexport function register(config) {\n  if (process.env.NODE_ENV === 'production' && 'serviceWorker' in navigator) {\n    // The URL constructor is available in all browsers that support SW.\n    const publicUrl = new URL(process.env.PUBLIC_URL, window.location.href);\n    if (publicUrl.origin !== window.location.origin) {\n      // Our service worker won't work if PUBLIC_URL is on a different origin\n      // from what our page is served on. This might happen if a CDN is used to\n      // serve assets; see https://github.com/facebook/create-react-app/issues/2374\n      return;\n    }\n\n    window.addEventListener('load', () => {\n      const swUrl = `${process.env.PUBLIC_URL}/service-worker.js`;\n\n      if (isLocalhost) {\n        // This is running on localhost. Let's check if a service worker still exists or not.\n        checkValidServiceWorker(swUrl, config);\n\n        // Add some additional logging to localhost, pointing developers to the\n        // service worker/PWA documentation.\n        navigator.serviceWorker.ready.then(() => {\n          console.log(\n            'This web app is being served cache-first by a service ' +\n              'worker. To learn more, visit https://bit.ly/CRA-PWA'\n          );\n        });\n      } else {\n        // Is not localhost. Just register service worker\n        registerValidSW(swUrl, config);\n      }\n    });\n  }\n}\n\nfunction registerValidSW(swUrl, config) {\n  navigator.serviceWorker\n    .register(swUrl)\n    .then(registration => {\n      registration.onupdatefound = () => {\n        const installingWorker = registration.installing;\n        if (installingWorker == null) {\n          return;\n        }\n        installingWorker.onstatechange = () => {\n          if (installingWorker.state === 'installed') {\n            if (navigator.serviceWorker.controller) {\n              // At this point, the updated precached content has been fetched,\n              // but the previous service worker will still serve the older\n              // content until all client tabs are closed.\n              console.log(\n                'New content is available and will be used when all ' +\n                  'tabs for this page are closed. See https://bit.ly/CRA-PWA.'\n              );\n\n              // Execute callback\n              if (config && config.onUpdate) {\n                config.onUpdate(registration);\n              }\n            } else {\n              // At this point, everything has been precached.\n              // It's the perfect time to display a\n              // \"Content is cached for offline use.\" message.\n              console.log('Content is cached for offline use.');\n\n              // Execute callback\n              if (config && config.onSuccess) {\n                config.onSuccess(registration);\n              }\n            }\n          }\n        };\n      };\n    })\n    .catch(error => {\n      console.error('Error during service worker registration:', error);\n    });\n}\n\nfunction checkValidServiceWorker(swUrl, config) {\n  // Check if the service worker can be found. If it can't reload the page.\n  fetch(swUrl)\n    .then(response => {\n      // Ensure service worker exists, and that we really are getting a JS file.\n      const contentType = response.headers.get('content-type');\n      if (\n        response.status === 404 ||\n        (contentType != null && contentType.indexOf('javascript') === -1)\n      ) {\n        // No service worker found. Probably a different app. Reload the page.\n        navigator.serviceWorker.ready.then(registration => {\n          registration.unregister().then(() => {\n            window.location.reload();\n          });\n        });\n      } else {\n        // Service worker found. Proceed as normal.\n        registerValidSW(swUrl, config);\n      }\n    })\n    .catch(() => {\n      console.log(\n        'No internet connection found. App is running in offline mode.'\n      );\n    });\n}\n\nexport function unregister() {\n  if ('serviceWorker' in navigator) {\n    navigator.serviceWorker.ready.then(registration => {\n      registration.unregister();\n    });\n  }\n}\n","import React from 'react';\nimport ReactDOM from 'react-dom';\nimport './index.css';\nimport App from './App';\nimport * as serviceWorker from './serviceWorker';\n\nReactDOM.render(<App />, document.getElementById('root'));\n\n// If you want your app to work offline and load faster, you can change\n// unregister() to register() below. Note this comes with some pitfalls.\n// Learn more about service workers: https://bit.ly/CRA-PWA\nserviceWorker.unregister();\n"],"sourceRoot":""}